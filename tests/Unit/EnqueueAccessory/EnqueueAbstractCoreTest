<?php
declare(strict_types=1);

namespace Ran\PluginLib\Tests\Unit\EnqueueAccessory;

use Ran\PluginLib\Config\ConfigInterface;
use Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract;
use Ran\PluginLib\Tests\Unit\PluginLibTestCase;
use Ran\PluginLib\Util\Logger;
use Mockery;
use ReflectionProperty;
use WP_Mock;
use Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait;
use Ran\PluginLib\EnqueueAccessory\StylesEnqueueTrait;
use Ran\PluginLib\EnqueueAccessory\MediaEnqueueTrait;

/**
 * Concrete implementation of EnqueueAbstract for testing core methods.
 */
class ConcreteEnqueueForCoreTesting extends EnqueueAssetBaseAbstract {
	use ScriptsEnqueueTrait, StylesEnqueueTrait, MediaEnqueueTrait;
	public function load(): void {
		// Mock implementation, does nothing for these tests.
	}

	// Expose protected properties for easier testing in this suite
	public function set_assets_for_testing(array $assets): void {
		$this->assets = $assets;
	}

	public function set_styles_for_testing(array $styles): void {
		$this->styles = $styles;
	}

	public function set_media_tool_configs_for_testing(array $media_configs): void {
		$this->media_tool_configs = $media_configs;
	}

	public function set_inline_assets_for_testing(array $inline_assets): void {
		$this->inline_assets = $inline_assets;
	}

	public function set_head_callbacks_for_testing(array $callbacks): void {
		$this->head_callbacks = $callbacks;
	}

	protected function _process_single_asset(
		array $asset_definition,
		string $processing_context,
		?string $hook_name = null,
		bool $do_register = true,
		bool $do_enqueue = false
	): string|false {
		// Mock implementation for testing.
		return $asset_definition['handle'] ?? false;
	}

	public function set_footer_callbacks_for_testing(array $callbacks): void {
		$this->footer_callbacks = $callbacks;
	}
}

/**
 * Class EnqueueAbstractCoreTest
 *
 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::enqueue
 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
 */
class EnqueueAbstractCoreTest extends PluginLibTestCase {
	// Properties $config_mock (ConcreteConfigForTesting) and $logger_mock (Mockery\MockInterface)
	// are now effectively inherited or will be correctly typed and populated.
	// We will ensure $this->logger_mock is a Mockery mock for setting expectations.
	protected ConcreteEnqueueForCoreTesting $sut;

	public function setUp(): void {
		parent::setUp(); // This sets up WP_Mock, config_mock, and logger_mock (the spy)
		WP_Mock::userFunction( '_doing_it_wrong' )->andReturnNull();

		// Instantiate the System Under Test (SUT) using the config mock from the parent.
		$this->sut = new ConcreteEnqueueForCoreTesting($this->config_mock);

		// Set up default permissive logging expectations on the logger spy.
		$this->logger_mock->shouldReceive('debug')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('info')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('warning')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('error')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('is_active')->withNoArgs()->zeroOrMoreTimes()->andReturn(true)->byDefault();
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::enqueue
	 */
	public function test_enqueue_processes_all_asset_types_when_present(): void {
		// 1. Create a mock config that will return our test logger.
		$local_config_mock = \Mockery::mock(ConfigInterface::class);
		$local_config_mock->shouldReceive('get_logger')->andReturn($this->logger_mock);

		// 2. Set precise logger expectations for the entire enqueue process.
		$this->expectLog('debug', ['Enqueue object initialized: '], 1, null);
		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Main enqueue process started.'], 1, null);
		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Found 1 scripts to process.'], 1, null);
		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Found 1 styles to process.'], 1, null);
		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Found 1 media items to process.'], 1, null);
		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Found 1 inline assets to process.'], 1, null);
		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Main enqueue process finished.'], 1, null);

		// 3. Create a partial mock of the SUT. This calls the real constructor.
		$sut = \Mockery::mock(ConcreteEnqueueForCoreTesting::class, array($local_config_mock))->makePartial();

		// 4. Set expectations to verify trait methods are called, and allow them to run.
		$sut->shouldReceive('enqueue_assets')->once()->passthru();
		$sut->shouldReceive('enqueue_styles')->once()->passthru();
		$sut->shouldReceive('enqueue_media')->once()->passthru();
		$sut->shouldReceive('enqueue_inline_assets')->once()->passthru();

		// 5. Populate assets on the SUT.
		$sut->set_assets_for_testing(array('general' => array(array('handle' => 'test-script'))));
		$sut->set_styles_for_testing(array('general' => array(array('handle' => 'test-style'))));
		$sut->set_media_tool_configs_for_testing(array(array('args' => array('post' => 1))));
		$sut->set_inline_assets_for_testing(array(array('handle' => 'test-script', 'data' => 'var a = 1;')));

		// 6. Call the method under test.
		$sut->enqueue();

		// Mockery verifies all expectations automatically on teardown.
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::enqueue
	 */
	public function test_enqueue_skips_processing_for_absent_asset_types(): void {
		$this->enable_console_logging = true;

		$sut_partial_mock = Mockery::mock(ConcreteEnqueueForCoreTesting::class, array($this->config_mock))->makePartial();
		$sut_partial_mock->shouldAllowMockingProtectedMethods();

		// Ensure all asset arrays are empty
		$sut_partial_mock->set_assets_for_testing(array());
		$sut_partial_mock->set_styles_for_testing(array());
		$sut_partial_mock->set_media_tool_configs_for_testing(array());
		$sut_partial_mock->set_inline_assets_for_testing(array()); // enqueue_inline_assets is always called

		// Expect that no WP enqueueing functions are called since all asset arrays are empty.
		WP_Mock::userFunction('wp_enqueue_script')->never();
		WP_Mock::userFunction('wp_enqueue_style')->never();
		WP_Mock::userFunction('wp_add_inline_script')->never();
		WP_Mock::userFunction('wp_enqueue_media')->never();

		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Main enqueue process started.'], 1, null);
		// Logging for empty assets is now handled within the respective trait methods.
		// The enqueue method in the base class now always calls these handlers.
		$sut_partial_mock->shouldReceive('enqueue_assets')->once()->ordered()->andReturnSelf();
		$sut_partial_mock->shouldReceive('enqueue_styles')->once()->ordered()->andReturnSelf();
		$sut_partial_mock->shouldReceive('enqueue_media')->once()->ordered()->andReturnSelf();
		// enqueue_inline_assets is always called, it handles its own empty state logging.
		$sut_partial_mock->shouldReceive('enqueue_inline_assets')->once()->ordered()->andReturnSelf();

		$this->expectLog('debug', ['EnqueueAssetBaseAbstract::enqueue - Main enqueue process finished.'], 1, null);

		$sut_partial_mock->enqueue();

		// Add a dummy assertion to prevent the test from being marked as risky.
		// The actual assertions are the Mockery and WP_Mock expectations.
		$this->assertTrue(true, 'Test ran to completion and expectations were met.');
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_executes_simple_callbacks(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'head_test_output_1';
		    }, 'condition' => null),
		    array('callback' => function() {
		    	echo 'head_test_output_2';
		    }, 'condition' => null),
		);
		$this->sut->set_head_callbacks_for_testing($callbacks);

		$this->expectLog('debug', array('render_head', 'Executing head callback 0.'), 1, null);
		$this->expectLog('debug', array('render_head', 'Executing head callback 1.'), 1, null);

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();

		$this->assertEquals('head_test_output_1head_test_output_2', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_executes_conditional_callbacks_when_condition_true(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_head_true';
		    }, 'condition' => function() {
		    	return true;
		    })
		);
		$this->sut->set_head_callbacks_for_testing($callbacks);
		$this->logger_mock->shouldReceive('debug')->with('EnqueueAssetBaseAbstract::render_head - Executing head callback 0.')->once();

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();
		$this->assertEquals('conditional_head_true', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_skips_conditional_callbacks_when_condition_false(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_head_false';
		    }, 'condition' => function() {
		    	return false;
		    })
		);
		$this->sut->set_head_callbacks_for_testing($callbacks);
		$this->expectLog('debug', array('render_head', 'Skipping head callback 0 due to false condition.'), 1, null);

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_handles_no_callbacks_gracefully(): void {
		$this->sut->set_head_callbacks_for_testing(array());
		$this->expectLog('debug', array('render_head', 'No head callbacks to execute.'), 1, null);

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_executes_simple_callbacks(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'footer_test_output_1';
		    }, 'condition' => null),
		    array('callback' => function() {
		    	echo 'footer_test_output_2';
		    }, 'condition' => null),
		);
		$this->sut->set_footer_callbacks_for_testing($callbacks);

		$this->expectLog('debug', array('render_footer', 'Executing footer callback 0.'), 1, null);
		$this->expectLog('debug', array('render_footer', 'Executing footer callback 1.'), 1, null);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();

		$this->assertEquals('footer_test_output_1footer_test_output_2', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_executes_conditional_callbacks_when_condition_true(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_footer_true';
		    }, 'condition' => function() {
		    	return true;
		    })
		);
		$this->sut->set_footer_callbacks_for_testing($callbacks);
		$this->expectLog('debug', array('render_footer', 'Executing footer callback 0.'), 1, null);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();
		$this->assertEquals('conditional_footer_true', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_skips_conditional_callbacks_when_condition_false(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_footer_false';
		    }, 'condition' => function() {
		    	return false;
		    })
		);
		$this->sut->set_footer_callbacks_for_testing($callbacks);
		$this->expectLog('debug', array('render_footer', 'Skipping footer callback 0 due to false condition.'), 1, null);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_handles_no_callbacks_gracefully(): void {
		$this->sut->set_footer_callbacks_for_testing(array());
		$this->expectLog('debug', array('render_footer', 'No footer callbacks to execute.'), 1, null);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}
}
