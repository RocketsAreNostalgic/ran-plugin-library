<?php
declare(strict_types=1);

namespace Ran\PluginLib\Tests\Unit\EnqueueAccessory;

use Ran\PluginLib\Config\ConfigInterface;
use Ran\PluginLib\Tests\Unit\PluginLibTestCase;
use Ran\PluginLib\EnqueueAccessory\EnqueueAssetTraitBase;
use Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract;
use Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait;
use Ran\PluginLib\Util\Logger;
use InvalidArgumentException;
use WP_Mock;
use Mockery;

/**
 * Concrete implementation of ScriptsEnqueueTrait for testing asset-related methods.
 */
class ConcreteEnqueueForScriptsTesting extends EnqueueAssetBaseAbstract {
	public function __construct(ConfigInterface $config, Logger $logger) {
		parent::__construct($config);
		$this->config = $config;
		$this->logger = $logger;
	}

	public function load(): void {
		// Minimal implementation for testing purposes.
	}

	public function get_logger(): Logger {
		return $this->logger;
	}

	// Mocked implementation for trait's dependency.
	protected function _get_wp_script_attributes(string $handle): array {
		return array();
	}

	// Mocked implementation for trait's dependency.
	protected function _add_action(string $hook, callable $callback, int $priority = 10, int $accepted_args = 1): void {
	}

	// Expose protected property for testing
	public function get_internal_inline_assets_array(): array {
		return $this->get_inline_assets('scripts');
	}

	protected function _get_asset_type(): string {
		return 'script';
	}
}

/**
 * Class ScriptsEnqueueTraitTest
 *
 * @package Ran\PluginLib\Tests\Unit\EnqueueAccessory
 *
 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait
 */
class ScriptsEnqueueTraitTest extends PluginLibTestCase {
	/**
	 * @var (ConcreteEnqueueForScriptsTesting&Mockery\MockInterface)|Mockery\LegacyMockInterface
	 */
	protected $instance;

	/**
	 * @var Logger|MockInterface
	 */
	protected ?\Mockery\MockInterface $logger_mock = null;

	/**
	 * Set up test environment.
	 */
	public function setUp(): void {
		parent::setUp();
		$this->logger_mock = Mockery::mock(Logger::class);
		$this->logger_mock->shouldReceive('is_active')->andReturn(false); // Default to inactive

		$config_mock = Mockery::mock(\Ran\PluginLib\Config\ConfigInterface::class);
		$config_mock->shouldReceive('get_logger')->andReturn($this->logger_mock);

		$this->instance = Mockery::mock(ConcreteEnqueueForScriptsTesting::class, array($config_mock, $this->logger_mock))->makePartial();
		$this->instance->shouldAllowMockingProtectedMethods();

		// Default WP_Mock function mocks for asset functions
		WP_Mock::userFunction('wp_register_script')->withAnyArgs()->andReturn(true)->byDefault();
		WP_Mock::userFunction('wp_enqueue_script')->withAnyArgs()->andReturnNull()->byDefault();
		WP_Mock::userFunction('wp_add_inline_script')->withAnyArgs()->andReturn(true)->byDefault();
		WP_Mock::userFunction('wp_script_add_data')->withAnyArgs()->andReturn(true)->byDefault();
		WP_Mock::userFunction('did_action')->withAnyArgs()->andReturn(0)->byDefault(); // 0 means false
		WP_Mock::userFunction('current_action')->withAnyArgs()->andReturn(null)->byDefault();
		WP_Mock::userFunction('is_admin')->andReturn(false)->byDefault(); // Default to not admin context
		WP_Mock::userFunction('wp_doing_ajax')->andReturn(false)->byDefault();
		WP_Mock::userFunction('_doing_it_wrong')->withAnyArgs()->andReturnNull()->byDefault();
		// Tests that need `wp_script_is` should mock it directly.
		WP_Mock::userFunction('wp_json_encode', array(
			'return' => static fn($data) => json_encode($data),
		))->byDefault();
		WP_Mock::userFunction('esc_attr', array(
			'return' => static fn($text) => htmlspecialchars((string) $text, ENT_QUOTES, 'UTF-8'),
		))->byDefault();

		// Mock has_action to control its return value for specific tests
		WP_Mock::userFunction('has_action')
			->with(Mockery::any(), Mockery::any())
			->andReturnUsing(function ($hook, $callback) {
				// Default behavior: no action exists.
				// Tests can add more specific expectations.
				return false;
			})
			->byDefault();
	}

	/**
	 * Clean up test environment.
	 */
	public function tearDown(): void {
		parent::tearDown();
		Mockery::close();

		// Reset protected properties to ensure a clean state for each test.
		$reflection = new \ReflectionObject($this->instance);

		$props_to_reset = ['assets', 'inline_assets', 'deferred_assets'];

		foreach ($props_to_reset as $prop_name) {
			if ($reflection->hasProperty($prop_name)) {
				$property = $reflection->getProperty($prop_name);
				$property->setAccessible(true);
				$property->setValue($this->instance, []);
			}
		}
	}

	// ------------------------------------------------------------------------
	// Test Methods for Script Functionalities
	// ------------------------------------------------------------------------

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::add_scripts
	 * @covers \Ran\PluginLib\Util\Logger::debug
	 */
	public function test_add_scripts_should_store_assets_correctly(): void {
		$assets_to_add = array(
			array(
				'handle'    => 'my-asset-1',
				'src'       => 'path/to/my-asset-1.js',
				'deps'      => array('jquery-ui-asset'),
				'version'   => '1.0.0',
				'media'     => 'screen',
				'condition' => static fn() => true,
			),
			array(
				'handle'  => 'my-asset-2',
				'src'     => 'path/to/my-asset-2.js',
				'deps'    => array(),
				'version' => false, // Use plugin version
				'media'   => 'all',
				// No condition, should default to true
			),
		);
		$group_name = 'add_scripts';

		// Logger expectations for ScriptsEnqueueTrait::add_scripts() using the new helper.
		$this->expectLog('debug', array('add_', 'Entered', 'Adding 2'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding', 'Key: 0, Handle: my-asset-1, src: path/to/my-asset-1'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding', 'Key: 1, Handle: my-asset-2, src: path/to/my-asset-2'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding 2'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Exiting', 'count: 2'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'All current', 'my-asset-1, my-asset-2'), 1, $group_name);

		// Call the method under test
		$result = $this->instance->add_scripts($assets_to_add);

		// Assert chainability
		$this->assertSame($this->instance, $result,
			'add_scripts() should be chainable and return an instance of the class.'
		);

		// Retrieve and check stored assets
		$reflection = new \ReflectionClass(ConcreteEnqueueForScriptsTesting::class);
		$assets_prop = $reflection->getProperty('assets');
		$assets_prop->setAccessible(true);
		$stored_assets = $assets_prop->getValue($this->instance);

		$this->assertArrayHasKey('scripts', $stored_assets, 'The `scripts` key should exist in the assets property.');
		$this->assertCount(count($assets_to_add), $stored_assets['scripts'], 'Should have the same number of assets added.');

		$general_assets = $stored_assets['scripts'];

		$this->assertEquals('my-asset-1', $general_assets[0]['handle']);
		$this->assertEquals('path/to/my-asset-1.js', $general_assets[0]['src']);
		$this->assertEquals(array('jquery-ui-asset'), $general_assets[0]['deps']);
		$this->assertEquals('1.0.0', $general_assets[0]['version']);
		$this->assertEquals('screen', $general_assets[0]['media']);
		$this->assertTrue(is_callable($general_assets[0]['condition']));
		$this->assertTrue(($general_assets[0]['condition'])());

		// Check second asset (my-asset-2)
		if (isset($general_assets[1])) {
			$this->assertEquals('my-asset-2', $general_assets[1]['handle']);
			$this->assertEquals('path/to/my-asset-2.js', $general_assets[1]['src']);
			$this->assertEquals(array(), $general_assets[1]['deps']);
			$this->assertEquals(false, $general_assets[1]['version']); // As per input
			$this->assertEquals('all', $general_assets[1]['media']);
			// Check that 'condition' is not present if not provided and not yet processed to default
			$this->assertArrayNotHasKey('condition', $assets_to_add[1]);
			$this->assertArrayNotHasKey('condition', $general_assets[1]);
		}

		//Check asset properties
		$this->assertEquals('path/to/my-asset-1.js', $general_assets[0]['src']);
		$this->assertEquals('path/to/my-asset-2.js', $general_assets[1]['src']);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::add_scripts
	 */
	public function test_add_scripts_handles_single_asset_definition_correctly(): void {
		$asset_to_add = array(
			'handle' => 'single-asset',
			'src'    => 'path/to/single.js',
			'deps'   => array(),
		);

		$group_name = 'add_scripts_single';

		// Bypassing the expectLog helper to test the logger mock directly.
		$this->logger_mock
			->shouldReceive('debug')
			->once()
			->with(Mockery::on(function ($message) {
				return str_contains($message, 'add_')
					&& str_contains($message, 'Entered')
					&& str_contains($message, 'Current')
					&& str_contains($message, 'count: 0')
					&& str_contains($message, 'Adding 1 new');
			}));

		// Call the method under test
		$this->instance->add_scripts($asset_to_add);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::add_scripts
	 */
	public function test_add_scripts_handles_empty_input_gracefully(): void {
		// Logger expectations for add_scripts() with an empty array.
		$this->expectLog('debug', array('add_', 'Entered with empty array', 'No', 'to add'));

		// Call the method under test
		$this->instance->add_scripts(array());

		// Retrieve and check stored assets
		$retrieved_assets = $this->instance->get_scripts()['general'];
		$this->assertCount(0, $retrieved_assets, 'The assets queue should be empty.');
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::register_assets
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 */
	public function test_register_assets_registers_non_hooked_asset_correctly(): void {
		$asset_to_add = array(
			'handle'    => 'my-asset',
			'src'       => 'path/to/my-asset.js',
			'deps'      => array(),
			'version'   => '1.0',
			'in_footer' => false, // Correct attribute for scripts
		);

		$group_name = 'test_register_assets_registers_non_hooked_asset_correctly';

		// --- Logger Mocks for add_scripts() ---
		$this->expectLog('debug', array('add_', 'Entered', 'Current', 'count: 0', 'Adding 1 new'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding', 'Handle: my-asset', 'src: path/to/my-asset.js'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding 1', 'definition(s)', 'Current total: 0'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Exiting', 'New total', 'count: 1'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'All current', 'handles: my-asset'), 1, $group_name);

		$this->instance->add_scripts($asset_to_add);

		// --- WP_Mock and Logger Mocks for register_assets() ---
		$this->expectLog('debug', array('register_', 'Entered', 'Processing 1 '), 1, $group_name);
		$this->expectLog('debug', array('_process_single_asset', 'Processing', 'my-asset', 'context', 'register_'), 1, $group_name);

		// Use the helper to mock WP functions for the asset lifecycle.
		$this->_mock_asset_lifecycle_functions(
			'script',
			'wp_register_script',
			'wp_enqueue_script',
			'wp_script_is',
			$asset_to_add
		);

		$this->expectLog('debug', array('_process_single_asset', 'Registering', 'my-asset'), 1, $group_name);

		// Note: The call to wp_register_script is now mocked by _mock_asset_lifecycle_functions.
		// It sets up `wp_script_is` to return false then true, and `wp_register_script` to return true.

		// Mocks for inline asset processing
		$this->expectLog('debug', array('_process_inline_', 'Checking for inline', 'my-asset'), 1, $group_name);
		$this->expectLog('debug', array('_process_inline_', 'No inline assets found', 'my-asset'), 1, $group_name);
		$this->expectLog('debug', array('_process_single_asset', 'Finished processing', 'my-asset'), 1, $group_name);
		$this->expectLog('debug', array('register_', '- Exited', 'Remaining immediate', ': 1'), 1, $group_name);

		// Call the method under test
		$this->instance->register_assets();

		// Assert that the asset has been removed from the queue after registration.
		$reflection = new \ReflectionClass(ConcreteEnqueueForScriptsTesting::class);
		$assets_prop = $reflection->getProperty('assets');
		$assets_prop->setAccessible(true);
		$stored_assets = $assets_prop->getValue($this->instance);

		$this->assertArrayHasKey('scripts', $stored_assets, 'The `scripts` key should still exist in the assets property.');
		$this->assertCount(0, $stored_assets['scripts'], 'The scripts queue should be empty after registration.');
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::register_assets
	 */
	public function test_register_assets_defers_hooked_asset_correctly(): void {
		$asset_to_add = array(
			'handle' => 'my-deferred-asset',
			'src'    => 'path/to/deferred.js',
			'hook'   => 'admin_enqueue_assets',
		);
		$group_name = 'register_assets_deferred';
		// --- Logger Mocks for add_scripts() ---
		$this->expectLog('debug', array('add_', 'Entered', 'Adding 1 new'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding', 'Handle: my-deferred-asset'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding 1 '), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Exiting', 'count: 1'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'handles: my-deferred-asset'), 1, $group_name);

		$this->instance->add_scripts(array($asset_to_add));

		// --- WP_Mock and Logger Mocks for register_assets() ---
		WP_Mock::userFunction('has_action')
			->with('admin_enqueue_assets', array($this->instance, 'enqueue_deferred_assets'))
			->andReturn(false) // Mock that the action hasn't been added yet
			->ordered($group_name);

		WP_Mock::expectActionAdded('admin_enqueue_assets', array($this->instance, 'enqueue_deferred_assets'), 10, 1);

		$this->expectLog('debug', array('register_', 'Entered', 'Processing 1'), 1, $group_name);
		$this->expectLog('debug', array('register_', 'Processing', 'my-deferred-asset', 'original index: 0'), 1, $group_name);
		$this->expectLog('debug', array('register_', 'Deferring registration', 'my-deferred-asset', '(original index 0) to hook: admin_enqueue_assets'), 1, $group_name);
		$this->expectLog('debug', array('register_', 'Added action for', 'enqueue_deferred_assets', 'hook: admin_enqueue_assets'), 1, $group_name);
		$this->expectLog('debug', array('register_', 'Exited', 'Remaining immediate', '0', 'Total deferred', '1'), 1, $group_name);

		// Call the method under test
		$this->instance->register_assets();

		// Assert that the asset is in the deferred queue
		// Access protected property $deferred_assets for assertion
		$reflection           = new \ReflectionClass($this->instance);
		$deferred_assets_prop = $reflection->getProperty('deferred_assets');
		$deferred_assets_prop->setAccessible(true);
		$deferred_assets = $deferred_assets_prop->getValue($this->instance);

		$this->assertArrayHasKey('scripts', $deferred_assets, 'The `scripts` key should exist in the deferred_assets property.');
		$this->assertArrayHasKey('admin_enqueue_assets', $deferred_assets['scripts']);
		$this->assertCount(1, $deferred_assets['scripts']['admin_enqueue_assets']);
		$this->assertEquals('my-deferred-asset', $deferred_assets['scripts']['admin_enqueue_assets'][0]['handle']);

		// Assert that the main assets queue is empty as the asset was deferred
		// Access protected property $assets for assertion
		$assets_prop = $reflection->getProperty('assets');
		$assets_prop->setAccessible(true);
		$stored_assets = $assets_prop->getValue($this->instance);
		$this->assertArrayHasKey('scripts', $stored_assets, 'The `scripts` key should still exist in the assets property.');
		$this->assertCount(0, $stored_assets['scripts'], 'The scripts queue should be empty after deferral.');
		$assets_prop->setAccessible(true);
		$assets_array = $assets_prop->getValue($this->instance);
		$this->assertEmpty($assets_array);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::register_assets
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 */
	public function test_register_assets_skips_asset_if_condition_is_false(): void {
		$asset_to_add = array(
			'handle'    => 'my-conditional-asset',
			'src'       => 'path/to/conditional.js',
			'condition' => function () {
				return false;
			},
		);

		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->zeroOrMoreTimes()->andReturn(true);
		$this->logger_mock->shouldIgnoreMissing();
		$group_name = 'test_register_assets_skips_asset_if_condition_is_false';

		// We only need to assert the one critical log message to proves the success of the conditional logic.
		$this->expectLog('debug', array('_process_single_asset', 'Condition not met', 'my-conditional-asset', 'Skipping.'), 1, $group_name);

		// Add the asset to the queue. The permissive mock will ignore logs from this call.
		$this->instance->add_scripts(array($asset_to_add));

		// Assert that wp_register_script is never called, which is a key outcome.
		WP_Mock::userFunction('wp_register_script')->never();

		// Call the method under test
		$this->instance->register_assets();

		// Assert that the asset was processed and removed from the immediate queue
		$this->assertEmpty($this->instance->get_scripts()['general']);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetTraitBase::enqueue_assets
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_full_asset_lifecycle_from_add_to_enqueue(): void {
		$asset_to_add = array(
			'handle'    => 'my-basic-asset',
			'src'       => 'path/to/basic.js',
			'deps'      => array(),
			'version'   => '1.0',
			'in_footer' => false, // Correct attribute for scripts
		);

		$asset_type        = 'script';
		$register_function = 'wp_register_script';
		$enqueue_function  = 'wp_enqueue_script';
		$is_function       = 'wp_script_is';

		// Stage 1: Add the asset
		$this->instance->add_scripts(array($asset_to_add));
		$reflection  = new \ReflectionObject($this->instance);
		$assets_prop = $reflection->getProperty('assets');
		$assets_prop->setAccessible(true);
		$this->assertCount(1, $assets_prop->getValue($this->instance), 'Asset should be in the queue after add_assets.');

		// Stages 2 & 3: Register and Enqueue
		$this->_mock_asset_lifecycle_functions(
			'script',
			'wp_register_script',
			'wp_enqueue_script',
			'wp_script_is',
			$asset_to_add
		);

		// Act
		$this->instance->register_assets();
		$this->instance->enqueue_assets();

		// Assert: Verify the queue is empty
		$this->assertEmpty($this->instance->get_scripts()['general'], 'General asset queue should be empty after enqueue.');
	}

	/**
	 * Sets up WP_Mock expectations for a full asset lifecycle.
	 *
	 * @param string $asset_type         The type of asset ('script' or 'style').
	 * @param string $register_function  The name of the WordPress registration function.
	 * @param string $enqueue_function   The name of the WordPress enqueue function.
	 * @param string $is_function        The name of the WordPress status check function (e.g., 'wp_script_is').
	 * @param array  $asset_to_add       The asset definition array.
	 */
	private function _mock_asset_lifecycle_functions(
		string $asset_type,
		string $register_function,
		string $enqueue_function,
		string $is_function,
		array $asset_to_add
	): void {
		$handle = $asset_to_add['handle'];

		WP_Mock::userFunction($is_function)->with($handle, 'registered')->andReturn(false, true, true);
		WP_Mock::userFunction($is_function)->with($handle, 'enqueued')->andReturn(false);

		if ($asset_type === 'script') {
			WP_Mock::userFunction($register_function)->with($handle, $asset_to_add['src'], $asset_to_add['deps'], $asset_to_add['version'], false)->andReturn(true);
		} else {
			WP_Mock::userFunction($register_function)->with($handle, $asset_to_add['src'], $asset_to_add['deps'], $asset_to_add['version'], $asset_to_add['media'])->andReturn(true);
		}
		WP_Mock::userFunction($enqueue_function)->with($handle);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::enqueue_deferred_assets
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_enqueue_deferred_assets_processes_and_enqueues_asset_on_hook(): void {
		// Arrange
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		$asset_handle = 'my-deferred-asset';
		$hook_name    = 'wp_footer';

		$deferred_asset = array(
			'handle'    => $asset_handle,
			'src'       => 'path/to/deferred.js',
			'deps'      => array(),
			'version'   => '1.0',
			'in_footer' => false, // Correct attribute for scripts
			'hook'      => $hook_name,
		);

		$group_name = 'deferred';

		// --- Act 1: Add the asset ---
		$this->expectLog('debug', array('add_', 'Entered', 'Adding 1 new'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding', "Handle: {$asset_handle}"), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding 1'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Exiting', 'count: 1'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'All current', $asset_handle), 1, $group_name);
		$this->instance->add_scripts(array($deferred_asset));

		// --- Act 2: Register the asset (which defers it) ---
		$this->expectLog('debug', array('register_', 'Entered', 'Processing 1'), 1, $group_name);
		$this->expectLog('debug', array('register_', 'Processing', $asset_handle), 1, $group_name);
		$this->expectLog('debug', array('Deferring registration', $asset_handle, "hook: {$hook_name}"), 1, $group_name);
		WP_Mock::userFunction('has_action', array(
			'args'   => array($hook_name, array($this->instance, 'enqueue_deferred_assets')),
			'times'  => 1,
			'return' => false
		));
		WP_Mock::expectActionAdded($hook_name, array($this->instance, 'enqueue_deferred_assets'), 10, 1);
		$this->expectLog('debug', array('Added action for', 'enqueue_deferred_', "hook: {$hook_name}"), 1, $group_name);
		$this->expectLog('debug', array('register_', 'Exited', 'Remaining immediate', ': 1'), 1, $group_name);
		$this->instance->register_assets();

		// --- Assert state after registration ---
		$deferred_assets_prop = new \ReflectionProperty($this->instance, 'deferred_assets');
		$deferred_assets_prop->setAccessible(true);
		$current_deferred = $deferred_assets_prop->getValue($this->instance);
		$this->assertArrayHasKey($hook_name, $current_deferred);
		$this->assertCount(1, $current_deferred[$hook_name]);
		// The key for the asset definition within the hook's array is its original index.
		// In this test, we add a single asset, so its original index is 0.
		$this->assertArrayHasKey(0, $current_deferred[$hook_name]);
		$this->assertEquals($asset_handle, $current_deferred[$hook_name][0]['handle']);

		// --- Act 3: Trigger the deferred enqueue ---
		// This is the key fix: "Entered hook" not "Entered for hook"
		$this->expectLog('debug', array('enqueue_deferred_', 'Entered hook', $hook_name), 1, $group_name);
		$this->expectLog('debug', array('Processing deferred', $asset_handle, "hook: \"{$hook_name}\""), 1, $group_name);

		// Use the helper to mock WP functions for the asset lifecycle.
		$this->_mock_asset_lifecycle_functions(
			'script',
			'wp_register_script',
			'wp_enqueue_script',
			'wp_script_is',
			$deferred_asset
		);

		$this->expectLog('debug', array('Registering', "{$asset_handle}", "on hook '{$hook_name}'"), 1, $group_name);
		$this->expectLog('debug', array('Enqueuing', "{$asset_handle}", "on hook '{$hook_name}'"), 1, $group_name);
		$this->expectLog('debug', array('Finished processing', "{$asset_handle}", "on hook '{$hook_name}'"), 1, $group_name);

		// Final log in enqueue_deferred_assets
		$this->expectLog('debug', array('enqueue_deferred', 'Exited for hook', $hook_name), 1, $group_name);

		// Execute
		$this->instance->enqueue_deferred_assets($hook_name);

		// --- Assert final state ---
		$current_deferred_after = $deferred_assets_prop->getValue($this->instance);
		$this->assertArrayNotHasKey($hook_name, $current_deferred_after, 'Deferred assets for the hook should be cleared after processing.');
	} // End of test_enqueue_deferred_assets_processes_and_enqueues_asset_on_hook

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::enqueue_deferred_assets
	 */
	public function test_enqueue_deferred_assets_skips_if_hook_not_set(): void {
		$this->enable_console_logging = true;
		// Arrange
		$hook_name = 'non_existent_hook';
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		// Logger expectations
		$this->expectLog('debug', array('enqueue_deferred', 'Entered hook', $hook_name), 1, null);
		$this->expectLog('debug', array('enqueue_deferred', 'Hook', $hook_name, 'not found in deferred'), 1, null);

		// Act
		$this->instance->enqueue_deferred_assets($hook_name);

		// Assert
		// Mockery handles the primary assertions. This is a final state check for robustness.
		$deferred_assets_prop = new \ReflectionProperty($this->instance, 'deferred_assets');
		$deferred_assets_prop->setAccessible(true);
		$current_deferred = $deferred_assets_prop->getValue($this->instance);
		$this->assertArrayNotHasKey($hook_name, $current_deferred, 'Hook should not have been added to deferred_assets.');
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::enqueue_deferred_assets
	 */
	public function test_enqueue_deferred_assets_skips_if_hook_set_but_empty(): void {
		// Arrange
		$hook_name = 'empty_hook_for_assets';
		// Set the deferred_assets property to have the hook, but with an empty array of assets.
		$deferred_assets_prop = new \ReflectionProperty($this->instance, 'deferred_assets');
		$deferred_assets_prop->setAccessible(true);
		$deferred_assets_prop->setValue($this->instance, array($hook_name => array()));

		// Logger expectations
		$this->expectLog('debug', array('enqueue_deferred', 'Entered hook', $hook_name), 1, null);
		$this->expectLog('debug', array('enqueue_deferred', 'Hook', $hook_name, 'was set but had no', 'It has now been cleared.'), 1, null);

		// Act
		$this->instance->enqueue_deferred_assets($hook_name);

		// Assert
		$current_deferred = $deferred_assets_prop->getValue($this->instance);
		$this->assertArrayNotHasKey($hook_name, $current_deferred, 'The hook should be cleared from deferred assets.');
	}

	/**
	 * Tests basic addition of an inline asset when the logger is inactive.
	 */
	public function test_add_inline_asset_basic_no_logger() {
		// Arrange: Configure logger to be inactive for this test
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(false);

		$handle            = 'test-asset-handle';
		$content           = '.test-class { color: blue; }';
		$expected_position = 'after'; // Default

		// Act: Call the method under test
		$this->instance->add_inline_asset( $handle, $content );

		// Assert: Check the internal $inline_assets property
		$inline_assets = $this->get_protected_property_value( $this->instance, 'inline_assets' );

		$this->assertCount( 1, $inline_assets, 'Expected one inline asset to be added.' );
		$added_asset = $inline_assets[0];

		$this->assertEquals( $handle, $added_asset['handle'], 'Handle does not match.' );
		$this->assertEquals( $content, $added_asset['content'], 'Content does not match.' );
		$this->assertEquals( $expected_position, $added_asset['position'], 'Position does not match default.' );
		$this->assertNull( $added_asset['condition'], 'Condition should be null by default.' );
		$this->assertNull( $added_asset['parent_hook'], 'Parent hook should be null by default.' );
	}

	/**
	 * Tests addition of an inline asset with an active logger and ensures correct log messages.
	 */
	public function test_add_inline_asset_with_active_logger() {
		// Arrange
		$handle  = 'test-log-handle';
		$content = '.log-class { font-weight: bold; }';
		// inline_assets is reset to [] in setUp, so initial count is 0.
		$initial_inline_assets_count = 0;

		// Logger expectations
		$this->expectLog('debug', array('add_inline_', 'Entered', 'handle: ' . \esc_html($handle)));

		// No parent hook finding log expected in this basic case as $this->assets is empty.

		$this->expectLog('debug', array('add_inline_', 'Exiting', 'New total inline', 'count: 1'));

		// Act: Call the method under test
		$this->instance->add_inline_asset($handle, $content);

		// Assert: Check the internal $inline_assets property (basic check, primary assertion is logger)
		$inline_assets = $this->get_protected_property_value( $this->instance, 'inline_assets' );
		$this->assertCount($initial_inline_assets_count + 1, $inline_assets, 'Expected one inline asset to be added.');
		// Get the last added asset (which will be the first if initial_inline_assets_count is 0)
		$added_asset = $inline_assets[$initial_inline_assets_count];

		$this->assertEquals($handle, $added_asset['handle']);
		$this->assertEquals($content, $added_asset['content']);
	}

	/**
	 * Tests that add_inline_asset correctly associates a parent_hook
	 * from an existing registered asset if not explicitly provided.
	 */
	public function test_add_inline_asset_associates_parent_hook_from_registered_assets() {
		// Arrange: Configure logger to be active
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		$parent_handle               = 'parent-for-inline';
		$parent_hook_name            = 'my_custom_parent_hook';
		$inline_content              = 'console.log("Inline asset for parent: " + ' . \esc_html($parent_handle) . ');';
		$initial_inline_assets_count = 0; // As it's reset in setUp

		// Pre-populate the $assets property with a parent asset
		$parent_asset_definition = array(
			'handle'    => $parent_handle,
			'src'       => 'path/to/parent.js',
			'deps'      => array(),
			'ver'       => '1.0',
			'media'     => 'all',
			'hook'      => $parent_hook_name, // This is key
			'condition' => null,
			'extra'     => array(),
		);
		$assets_property = new \ReflectionProperty(ConcreteEnqueueForScriptsTesting::class, 'assets');
		$assets_property->setAccessible(true);
		$assets_property->setValue($this->instance, array($parent_asset_definition));

		// Logger expectations
		$this->expectLog('debug', array('add_inline_', 'Entered', 'Adding new inline', "for handle: {$parent_handle}"));
		$this->expectLog('debug', array("associated with parent hook: '{$parent_hook_name}'", 'Original parent', "hook: '{$parent_hook_name}'"), 1, null);
		$this->expectLog('debug', array('add_inline_', 'Exiting', 'New total inline', 'count: 1'), 1, null);

		// Act: Call the method under test, $parent_hook is null by default
		$this->instance->add_inline_asset($parent_handle, $inline_content);

		// Assert: Check the internal $inline_assets property
		$inline_assets_array = $this->get_protected_property_value($this->instance, 'inline_assets');
		$this->assertCount($initial_inline_assets_count + 1, $inline_assets_array, 'Expected one inline asset to be added.');

		$added_inline_asset = $inline_assets_array[$initial_inline_assets_count];
		$this->assertEquals($parent_handle, $added_inline_asset['handle']);
		$this->assertEquals($inline_content, $added_inline_asset['content']);
		$this->assertEquals($parent_hook_name, $added_inline_asset['parent_hook'], 'Parent hook was not correctly associated from the registered asset.');
	}

	// End of test_add_inline_asset_associates_parent_hook_from_registered_assets

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_process_inline_assets_logs_and_exits_if_inline_assets_globally_empty() {
		// Arrange
		$asset_handle       = 'test-parent-asset';
		$processing_context = 'direct_call'; // Context for this direct test
		$asset_definition   = array(
		    'handle'  => $asset_handle,
		    'src'     => 'path/to/asset.js',
		    'deps'    => array(),
		    'version' => false,
		    'media'   => 'all',
		);

		// Ensure $this->inline_assets is globally empty
		$inline_assets_property = new \ReflectionProperty(ConcreteEnqueueForScriptsTesting::class, 'inline_assets');
		$inline_assets_property->setAccessible(true);
		$inline_assets_property->setValue($this->instance, array());

		// Logger active for debug messages
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		// Ensure wp_script_is returns false so registration/enqueueing is attempted
		\WP_Mock::userFunction('wp_script_is')
			->with($asset_handle, 'registered')
		    ->andReturn(false);
		\WP_Mock::userFunction('wp_script_is')
			->with($asset_handle, 'enqueued')
		    ->andReturn(false);

		// --- Ordered Logger and WP_Mock expectations ---

		$order_group = 'process_asset_flow';

		// 1. Log from _process_single_asset entry
		$this->expectLog('debug', array('_process_single_', 'Processing', "'{$asset_handle}'", "in context '{$processing_context}'"), 1, $order_group);

		// 2. Log before wp_register_script
		$this->expectLog('debug', array('_process_single_', 'Registering', "'{$asset_handle}'"), 1, $order_group);

		// 3. Mock wp_register_script call, ensuring it returns true
		\WP_Mock::userFunction('wp_register_script')->once()
		    ->with($asset_handle, $asset_definition['src'], $asset_definition['deps'], $asset_definition['version'], false)
		    ->andReturn(true);

		// 4. Log before wp_enqueue_script
		$this->expectLog('debug', array('_process_single_', 'Enqueuing', "'{$asset_handle}'"), 1, $order_group);

		// 5. Mock wp_enqueue_script call
		\WP_Mock::userFunction('wp_enqueue_script')->once()->with($asset_handle);

		// 6. Log from _process_inline_assets entry
		$this->expectLog('debug', array('_process_inline_', 'Checking for inline', "for parent handle '{$asset_handle}'"), 1, $order_group);

		// 7. Log from _process_single_asset completion
		$this->expectLog('debug', array('_process_single_', 'Finished processing', "'{$asset_handle}'."), 1, $order_group);

		// Act: Call _process_single_asset directly using reflection
		$method = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_single_asset');
		$method->setAccessible(true);
		$method->invoke($this->instance, $asset_definition, $processing_context, null, true, true); // do_register=true, do_enqueue=true

		// Assert: Mockery will assert its expectations automatically.
		$this->assertTrue(true);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_process_inline_assets_skips_if_condition_is_false() {
		// Arrange
		$parent_handle      = 'test-parent-asset';
		$processing_context = 'direct_call';
		$asset_definition   = array(
			'handle'  => $parent_handle,
			'src'     => 'path/to/parent.js',
			'deps'    => array(),
			'version' => false,
			'media'   => 'all',
		);

		// Define an inline asset with a condition that returns false
		$inline_asset_with_condition = array(
			'handle'    => $parent_handle,
			'content'   => '.conditional-asset { display: none; }',
			'condition' => function () {
				return false;
			},
		);
		$inline_assets_property = new \ReflectionProperty(ConcreteEnqueueForScriptsTesting::class, 'inline_assets');
		$inline_assets_property->setAccessible(true);
		$inline_assets_property->setValue($this->instance, array($inline_asset_with_condition));

		// Logger active for debug messages
		$this->logger_mock->shouldReceive('is_active')->andReturn(true);
		$order_group = 'process_asset_flow';

		// Mocks for parent asset processing
		\WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'registered')->andReturn(false, true)->ordered($order_group);
		\WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'enqueued')->andReturn(false)->ordered($order_group);
		\WP_Mock::userFunction('wp_register_script')->once()->andReturn(true)->ordered($order_group);
		\WP_Mock::userFunction('wp_enqueue_script')->once()->ordered($order_group);

		// Crucially, wp_add_inline_script should NOT be called
		\WP_Mock::userFunction('wp_add_inline_script')->never()->ordered($order_group);

		// --- Ordered Logger expectations ---
		$this->expectLog('debug', array('_process_single_', 'Processing', "'{$parent_handle}' in context '{$processing_context}'"), 1, $order_group);
		$this->expectLog('debug', array('_process_single_', 'Registering', "'{$parent_handle}'"), 1, $order_group);
		$this->expectLog('debug', array('_process_single_', 'Enqueuing', "'{$parent_handle}'"), 1, $order_group);

		$this->expectLog('debug', array('_process_inline_', 'Checking for inline', "for parent handle '{$parent_handle}'"), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Condition false for inline', "targeting '{$parent_handle}'"), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Removed processed inline'), 1, $order_group);

		$this->expectLog('debug', array('_process_single_', 'Finished processing', "'{$parent_handle}'."), 1, $order_group);

		// Act
		$method = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_single_asset');
		$method->setAccessible(true);
		$method->invoke($this->instance, $asset_definition, $processing_context, null, true, true);

		// Assert
		$this->assertTrue(true);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_process_inline_assets_skips_if_content_is_empty() {
		// Arrange
		$parent_handle      = 'test-parent-asset';
		$processing_context = 'direct_call';
		$asset_definition   = array(
			'handle' => $parent_handle,
			'src'    => 'path/to/parent.js',
		);

		// Define an inline asset with empty content
		$inline_asset_empty_content = array(
			'handle'  => $parent_handle,
			'content' => '', // Empty content
		);
		$inline_assets_property = new \ReflectionProperty(ConcreteEnqueueForScriptsTesting::class, 'inline_assets');
		$inline_assets_property->setAccessible(true);
		$inline_assets_property->setValue($this->instance, array($inline_asset_empty_content));

		// Logger active for debug/warning messages
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		$order_group = 'process_asset_flow';

		// Mocks for parent asset processing
		\WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'registered')->andReturn(false, true)->ordered($order_group);
		\WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'enqueued')->andReturn(false)->ordered($order_group);
		\WP_Mock::userFunction('wp_register_script')->once()->andReturn(true)->ordered($order_group);
		\WP_Mock::userFunction('wp_enqueue_script')->once()->ordered($order_group);

		// Crucially, wp_add_inline_script should NOT be called
		\WP_Mock::userFunction('wp_add_inline_script')->never()->ordered($order_group);

		// --- Ordered Logger expectations ---
		$this->expectLog('debug', array('_process_single_', 'Processing',  "'{$parent_handle}'"), 1, $order_group);
		$this->expectLog('debug', array('_process_single_', 'Registering',  "'{$parent_handle}'"), 1, $order_group);
		$this->expectLog('debug', array('_process_single_', 'Enqueuing',  "'{$parent_handle}'"), 1, $order_group);

		$this->expectLog('debug', array('_process_inline_', 'Checking for inline',  "for parent handle '{$parent_handle}'"), 1, $order_group);
		// Target Log for this test
		$this->expectLog('warning', array('_process_inline_', 'Empty content for inline'), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Removed processed inline'), 1, $order_group);

		$this->expectLog('debug', array('_process_single_', 'Finished processing', "'{$parent_handle}'"), 1, $order_group);

		// Act
		$method = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_single_asset');
		$method->setAccessible(true);
		$method->invoke($this->instance, $asset_definition, $processing_context, null, true, true);

		// Assert
		$this->assertTrue(true);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_process_inline_assets_adds_asset_successfully() {
		// Arrange
		$parent_handle = 'test-parent-asset';

		$inline_content  = 'console.log("Inline asset for parent: " + ' . \esc_html($parent_handle) . ');';
		$inline_position = 'after';

		// Define a valid inline asset
		$valid_inline_asset = array(
			'handle'   => $parent_handle,
			'content'  => $inline_content,
			'position' => $inline_position,
		);
		$inline_assets_property = new \ReflectionProperty(ConcreteEnqueueForScriptsTesting::class, 'inline_assets');
		$inline_assets_property->setAccessible(true);
		$inline_assets_property->setValue($this->instance, array($valid_inline_asset));

		// Logger active for debug messages
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		// Mocks for parent asset processing. We assume the asset is already registered and enqueued.
		\WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'registered')->andReturn(true);
		\WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'enqueued')->andReturn(true);

		// Because the asset is already registered/enqueued, these should not be called.
		\WP_Mock::userFunction('wp_register_script')->never();
		\WP_Mock::userFunction('wp_enqueue_script')->never();

		// Crucially, wp_add_inline_script SHOULD be called and return true
		\WP_Mock::userFunction('wp_add_inline_script')->once()
			->with($parent_handle, $inline_content, $inline_position)
			->andReturn(true);


		// --- Ordered Logger expectations ---
		$order_group = 'log_order';
		$this->expectLog('debug', array('enqueue_inline_', 'Entered method.'), 1, $order_group);
		$this->expectLog('debug', array('enqueue_inline_', 'Found 1 unique parent handle(s)', $parent_handle), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', "Checking for inline assets for parent handle '{$parent_handle}'"), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', "Adding inline asset for '{$parent_handle}'", "position: {$inline_position}"), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Removed processed inline asset', $parent_handle), 1, $order_group);
		$this->expectLog('debug', array('enqueue_inline_', 'Exited.', 'Remaining deferred inline', '0'), 1, $order_group);
		// Act
		$this->instance->enqueue_inline_assets();

		// Assert: WP_Mock and Mockery will verify expectations.
		$this->assertTrue(true); // Assertion handled by Mockery expectations
	}

	/**
	 * @dataProvider provide_asset_edge_cases
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 *
	 * @param array       $asset_definition The asset definition array.
	 * @param array       $wp_mocks          The WordPress function mocks.
	 * @param array       $expected_logs     The expected log messages.
	 * @param string|bool $expected_return   The expected return value.
	 * @param array|null  $sut_mocks         Optional. Mocks for the System Under Test.
	 *
	 * @return void
	 * @throws \ReflectionException
	 */
	public function skip_test_process_single_asset_handles_edge_cases(array $test_case): void {
		$asset_definition = $test_case['asset_definition'];
		$wp_mocks         = $test_case['wp_mocks'];
		$logger_expects   = $test_case['logger_expects'];
		$expected_return  = $test_case['expected_return'];
		$sut_mocks        = $test_case['sut_mocks'] ?? null;

		if ( ! empty( $sut_mocks ) ) {
			$this->_setup_sut_mocks( $sut_mocks );
		}

		$this->_setup_wp_mocks($wp_mocks);

		// Set up logger expectations
		if (!empty($logger_expects)) {
			$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);
			foreach ($logger_expects as $expectation) {
				if (!is_array($expectation) || count($expectation) < 2) {
					throw new InvalidArgumentException('Each log expectation must be an array with at least a level and a message array.');
				}
				// Unpack all parameters, providing default values
				$level       = $expectation[0];
				$messages    = $expectation[1];
				$times       = $expectation[2] ?? 1;
				$order_group = $expectation[3] ?? null;
				$debug       = $expectation[4] ?? false;

				$this->expectLog($level, $messages, $times, $order_group, $debug);
			}
		} else {
			$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(false);
		}

		$result = $this->_invoke_protected_method(
			$this->instance,
			'_process_single_asset',
			array(
				$asset_definition,
				'test_context', // This context is generic for the data provider
				$test_case['hook_name']   ?? null,
				$test_case['do_register'] ?? true,
				$test_case['do_enqueue']  ?? true,
			)
		);

		$this->assertEquals($expected_return, $result);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 */
	public function test_process_single_asset_logs_warning_for_id_attribute(): void {
		// Arrange
		$asset_definition = array(
			'handle'     => 'id-asset',
			'src'        => 'path/id.js',
			'attributes' => array('id' => 'custom-id'),
		);

		WP_Mock::userFunction('wp_script_is')->with('id-asset', 'registered')->andReturn(false);
		WP_Mock::userFunction('wp_register_script')->with('id-asset', 'path/id.js', array(), false, false)->andReturn(true);
		WP_Mock::userFunction('wp_script_is')->with('id-asset', 'enqueued')->andReturn(false);
		WP_Mock::userFunction('wp_enqueue_script')->with('id-asset')->andReturnNull();

		// The 'id' attribute is managed by WordPress core. The system should log a warning
		// but should NOT add the 'asset_loader_tag' filter, as it would be incorrect to
		// attempt to override the ID.
		$this->logger_mock->shouldReceive('warning')
			->with(Mockery::pattern("/Attempting to set 'id' attribute for 'id-asset'/"))
			->once();

		// Act
		$result = $this->_invoke_protected_method(
			$this->instance,
			'_process_single_asset',
			array($asset_definition, 'test_context')
		);

		// Assert
		$this->assertEquals('id-asset', $result);
	}

	/**
	 * Provides test cases for asset edge cases.
	 *
	 * @return array
	 */
	public function provide_asset_edge_cases(): array {
		return array(
			'registration_fails' => array(
				array(
					'asset_definition' => array('handle' => 'fail-asset', 'src' => 'path/fail.js'),
					'wp_mocks'         => array(
						'wp_script_is'       => array('args' => array('fail-asset', 'registered'), 'return' => false),
						'wp_register_script' => array('args' => array('fail-asset', 'path/fail.js', array(), false, false), 'return' => false),
					),
					'logger_expects' => array(
						array('warning', array('wp_register_script() failed for handle')),
					),
					'expected_return' => false,
				),
			),
			'invalid_definition_no_src' => array(
				array(
					'asset_definition' => array('handle' => 'no-src-asset'),
					'wp_mocks'         => array(),
					'logger_expects'   => array(
						array('warning', array('Invalid', 'Missing handle or src')),
					),
					'expected_return' => false,
				),
			),
			'async_add_data_fails' => array(
				array(
					'asset_definition' => array('handle' => 'async-fail', 'src' => 'path/async.js', 'attributes' => array('async' => true)),
					'wp_mocks'         => array(
						'wp_script_is' => array(
							array('args' => array('async-fail', 'registered'), 'return' => false, 'times' => 2),
							array('args' => array('async-fail', 'enqueued'), 'return' => false, 'times' => 2),
						),
						'wp_register_script' => array('return' => true),
						'wp_script_add_data' => array('args' => array('async-fail', 'strategy', 'async'), 'return' => false),
					),
					'logger_expects' => array(
						array('warning', array("Failed to add 'async' strategy")),
					),
					'expected_return' => 'async-fail',
				),
			),
			'defer_add_data_fails' => array(
				array(
					'asset_definition' => array('handle' => 'defer-fail', 'src' => 'path/defer.js', 'attributes' => array('defer' => true)),
					'wp_mocks'         => array(
						'wp_script_is' => array(
							array('args' => array('defer-fail', 'registered'), 'return' => false, 'times' => 2),
							array('args' => array('defer-fail', 'enqueued'), 'return' => false, 'atLeast' => true),
						),
						'wp_register_script' => array('return' => true),
						'wp_script_add_data' => array('args' => array('defer-fail', 'strategy', 'defer'), 'return' => false),
					),
					'logger_expects' => array(
						array('warning', array("Failed to add 'defer' strategy")),
					),
					'expected_return' => 'defer-fail',
				),
			),
			'src_attribute_ignored' => array(
				array(
					'asset_definition' => array(
						'handle'     => 'src-asset',
						'src'        => 'path/src.js',
						'attributes' => array('src' => 'ignored.js'),
					),
					'wp_mocks' => array(
						'wp_script_is' => array(
							array('args' => array('src-asset', 'registered'), 'return' => false, 'times' => 2),
							array('args' => array('src-asset', 'enqueued'), 'return' => false, 'atLeast' => true),
						),
						'wp_register_script' => array('return' => true),
					),
					'logger_expects' => array(
						array('debug', array("Ignoring 'src' attribute")),
					),
					'expected_return' => 'src-asset',
				),
			),
		);
	}

	/**
	 * Sets up the SUT (System Under Test) mocks based on the provided expectations.
	 *
	 * @param array $sut_mocks An array of expectations, where each expectation is an array with the following keys:
	 *     - 'method' (string): The name of the method to mock.
	 *     - 'args' (array, optional): The arguments to pass to the method.
	 *     - 'return' (mixed, optional): The return value of the method.
	 *     - 'times' (int, optional): The number of times the method should be called. Defaults to 1.
	 */
	protected function _setup_sut_mocks(array $sut_mocks): void {
		foreach ($sut_mocks as $method => $details) {
			$expectation = $this->instance->shouldReceive($method);

			if (isset($details['args'])) {
				$expectation->withArgs($details['args']);
			} else {
				$expectation->withAnyArgs();
			}

			if (array_key_exists('return', $details)) {
				$expectation->andReturn($details['return']);
			}

			if (isset($details['times'])) {
				$expectation->times($details['times']);
			} else {
				$expectation->once();
			}
		}
	}

	/**
	 * Sets up WordPress function mocks based on the provided expectations.
	 *
	 * @param array $expectations An array of expectations, where each expectation is an array with the following keys:
	 *     - 'func_name' (string): The name of the function to mock.
	 *     - 'args' (array, optional): The arguments to pass to the function.
	 *     - 'return' (mixed, optional): The return value of the function.
	 *     - 'times' (int, optional): The number of times the function should be called. Defaults to 1.
	 */
	protected function _setup_wp_mocks(array $expectations): void {
		foreach ($expectations as $func_name => $details) {
			// If the details array is indexed (i.e., a list of mocks), iterate through them.
			// Otherwise, treat it as a single mock definition.
			$mocks = (isset($details[0]) && is_array($details[0])) ? $details : array($details);

			foreach ($mocks as $mock_details) {
				$expectation = WP_Mock::userFunction($func_name);

				if (!empty($mock_details['atLeast'])) {
					$expectation->atLeast()->once();
				} else {
					$times = $mock_details['times'] ?? 1;
					$expectation->times($times);
				}

				if (isset($mock_details['args'])) {
					$expectation->with(...$mock_details['args']);
				} else {
					$expectation->withAnyArgs();
				}

				if (array_key_exists('return', $mock_details)) {
					if (is_array($mock_details['return']) && !empty($mock_details['return'])) {
						$expectation->andReturn(...$mock_details['return']);
					} else {
						$expectation->andReturn($mock_details['return']);
					}
				}
			}
		}
	}

	/**
	 * Invokes a protected method on an object.
	 *
	 * @param object $object The object to call the method on.
	 * @param string $methodName The name of the method to call.
	 * @param array  $parameters An array of parameters to pass to the method.
	 * @return mixed The result of the method call.
	 * @throws \ReflectionException If the method does not exist.
	 */
	protected function _invoke_protected_method(object $object, string $methodName, array $parameters = array()) {
		$class = new \ReflectionClass($object);
		while ($class && ! $class->hasMethod($methodName)) {
			$class = $class->getParentClass();
		}
		if (! $class) {
			throw new \ReflectionException(
				sprintf(
					'Method %s() does not exist in class %s or any of its parents.',
					$methodName,
					get_class($object)
				)
			);
		}
		$method = $class->getMethod($methodName);
		$method->setAccessible(true);

		return $method->invokeArgs($object, $parameters);
	}

	/**
	 * Tests enqueue_inline_assets when only deferred inline assets are present.
	 * (i.e., all inline assets have a parent_hook set)
	 */
	public function test_enqueue_inline_assets_only_deferred_assets_present() {
		// Arrange: Logger is active
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		// Pre-populate $this->inline_assets with a deferred asset
		$deferred_inline_asset = array(
			'handle'      => 'deferred-handle',
			'content'     => '.deferred { color: red; }',
			'position'    => 'after',
			'condition'   => null,
			'parent_hook' => 'some_action_hook', // Key: this makes it deferred
		);
		$inline_assets_property = new \ReflectionProperty(ConcreteEnqueueForScriptsTesting::class, 'inline_assets');
		$inline_assets_property->setAccessible(true);
		$inline_assets_property->setValue($this->instance, array($deferred_inline_asset));

		$this->expectLog('debug', array('enqueue_inline_', 'Entered method.'), 1, null);
		$this->expectLog('debug', array('enqueue_inline_', 'No immediate inline', 'found needing processing.'), 1, null);

		// Act: Call the method under test
		$result = $this->instance->enqueue_inline_assets();

		// Assert: Method returns $this for chaining
		$this->assertSame($this->instance, $result, 'Method should return $this for chaining.');
		// Mockery will assert that all expected log calls were made.
	} // End of test_enqueue_inline_assets_only_deferred_assets_present

	/**
	 * Tests enqueue_inline_assets processes a single immediate inline asset,
	 * including logging and call to wp_add_inline_script.
	 *
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::enqueue_inline_assets
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_enqueue_inline_assets_processes_one_immediate_asset(): void {
		// Arrange
		$handle      = 'test-immediate-handle';
		$content     = '.immediate { border: 1px solid green; }';
		$position    = 'after';
		$order_group = 'enqueue_inline_assets';

		// Use the public method to add the asset, which is cleaner than reflection.
		$this->instance->add_inline_asset($handle, $content, $position);

		// Logger must be active for logs to be processed.
		$this->logger_mock->shouldReceive('is_active')->andReturn(true);

		// Set up the full, ordered sequence of expected log messages.
		$this->expectLog('debug', array('enqueue_inline_', 'Entered method.'), 1, $order_group);
		$this->expectLog('debug', array('enqueue_inline_', 'Found 1 unique parent handle(s)', 'to process: test-immediate-handle'), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Checking for inline', "for parent handle 'test-immediate-handle'"), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Adding inline', "'test-immediate-handle' (key: 0, position: {$position})"), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Successfully added inline', "'test-immediate-handle' with wp_add_inline_script"), 1, $order_group);
		$this->expectLog('debug', array('_process_inline_', 'Removed processed inline', "with key '0' for handle 'test-immediate-handle'"), 1, $order_group);
		$this->expectLog('debug', array('enqueue_inline_', 'Exited. Processed 1 parent handle(s). Remaining deferred inline', '0'), 1, $order_group);

		// Mock WordPress functions that are called during processing.
		WP_Mock::userFunction('wp_script_is', array('args' => array($handle, 'registered'), 'return' => true, 'times' => 1))->ordered($order_group);
		WP_Mock::userFunction('wp_add_inline_script', array('args' => array($handle, $content, $position), 'return' => true, 'times' => 1))->ordered($order_group);

		// Act
		$result = $this->instance->enqueue_inline_assets();

		// Assert
		$this->assertSame($this->instance, $result, 'Method should return $this for chaining.');
		$this->assertEmpty($this->get_protected_property_value($this->instance, 'inline_assets'), 'Inline assets queue should be empty after processing.');
	}

	/**
	 * Tests that enqueue_inline_assets skips invalid (non-array) inline asset data
	 * and processes any valid immediate assets that might also be present.
	 */
	public function test_enqueue_inline_assets_skips_invalid_non_array_inline_asset_data() {
		// Arrange: Logger is active
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

		$valid_handle   = 'valid-handle-amidst-invalid';
		$valid_content  = '.valid-content { background: white; }';
		$valid_position = 'before';

		$valid_immediate_asset = array(
			'handle'      => $valid_handle,
			'content'     => $valid_content,
			'position'    => $valid_position,
			'condition'   => null,
			'parent_hook' => null, // Immediate
		);
		$invalid_asset_item = 'this is definitely not an array'; // The invalid item

		// Set $inline_assets with the invalid item first, then the valid one.
		// Keys will be 0 (invalid) and 1 (valid).
		$inline_assets_property = new \ReflectionProperty(ConcreteEnqueueForScriptsTesting::class, 'inline_assets');
		$inline_assets_property->setAccessible(true);
		$inline_assets_property->setValue($this->instance, array($invalid_asset_item, $valid_immediate_asset));

		// --- Simplified Expectations ---
		// The core behavior we're testing is that invalid data is identified and skipped.
		// The warning is logged twice, so we expect it twice.
		$this->expectLog('warning', array('Invalid inline', "data at key '0'"), 2, null);

		// We still need to mock the WordPress functions that are called for the *valid* asset,
		// otherwise the test will fail when those functions are called.
		// Note: No 'ordered()' call, making the test less brittle.
		\WP_Mock::userFunction('wp_script_is')->with($valid_handle, 'registered')->andReturn(false);
		\WP_Mock::userFunction('wp_script_is')->with($valid_handle, 'enqueued')->andReturn(true);
		\WP_Mock::userFunction('wp_add_inline_script')->with($valid_handle, $valid_content, $valid_position)->andReturn(true);

		// Act
		$result = $this->instance->enqueue_inline_assets();

		// Assert
		$this->assertSame($this->instance, $result, 'Method should return $this for chaining.');
		// Mockery and WP_Mock will assert their expectations.
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::register_assets
	 * Tests that the correct log message is emitted when attempting to add a deferred asset action
	 * for a hook that already has that action registered.
	 */
	public function test_register_assets_logs_when_deferred_action_already_exists() {
		// Arrange
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->zeroOrMoreTimes()->andReturn(true);
		$this->logger_mock->shouldIgnoreMissing();

		$hook_name     = 'my_custom_hook';
		$asset1_handle = 'deferred-asset-1';
		$asset2_handle = 'deferred-asset-2';

		$assets_data = array(
			$asset1_handle => array(
				'handle' => $asset1_handle,
				'src'    => 'path/to/asset1.js',
				'deps'   => array(),
				'ver'    => false,
				'media'  => 'all',
				'hook'   => $hook_name,
			),
			$asset2_handle => array(
				'handle' => $asset2_handle,
				'src'    => 'path/to/asset2.js',
				'hook'   => $hook_name, // Same hook
			),
		);

		$this->instance->add_scripts($assets_data);

		$testInstance    = $this->instance; // Capture $this->instance for the closure
		$callbackMatcher = \Mockery::on(function ($actual_callback_arg) use ($testInstance) {
			if (!is_array($actual_callback_arg) || count($actual_callback_arg) !== 2) {
				return false;
			}
			// Exact instance check
			if ($actual_callback_arg[0] !== $testInstance) {
				return false;
			}
			if ($actual_callback_arg[1] !== 'enqueue_deferred_assets') {
				return false;
			}
			return true;
		});

		$has_action_call_count = 0;
		\WP_Mock::userFunction('has_action')
			->times(2) // Expect has_action to be called twice
			->with($hook_name, $callbackMatcher)
			->andReturnUsing(function () use (&$has_action_call_count) {
				$has_action_call_count++;
				if ($has_action_call_count === 1) {
					return false; // First call, action doesn't exist
				}
				return true; // Second call, action now exists
			});

		// Expect that the action is added exactly once.
		\WP_Mock::expectActionAdded($hook_name, array( $this->instance, 'enqueue_deferred_assets' ), 10, 1);

		// --- Corrected Logger Expectations ---
		// Based on the source code, these are the two logs that should appear, once each.
		$this->expectLog('debug', array("Added action for 'enqueue_deferred_assets' on hook: {$hook_name}.", 1));
		$this->expectLog('debug', array("Action for 'enqueue_deferred_assets' on hook '{$hook_name}' already exists.", 1));


		// Act
		$this->instance->register_assets();

		// Assert (WP_Mock and Mockery will verify expectations)
		$this->assertTrue(true);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * Tests that _process_single_asset logs and skips registration if a asset is already registered.
	 */
	public function test_process_single_asset_logs_when_asset_already_registered_and_skips_reregistration(): void {
		$asset_handle = 'my-already-registered-asset';
		$asset_src    = 'path/to/asset.js';
		$assets_data  = array(
			$asset_handle => array(
				'handle' => $asset_handle,
				'src'    => $asset_src,
				'hook'   => null, // Process immediately
			),
		);
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->zeroOrMoreTimes()->andReturn(true);
		$this->logger_mock->shouldIgnoreMissing();

		$group_name = 'process_single_asset';

		// Set up logger expectations for add_assets
		$this->expectLog('debug', array('add_', 'Entered', 'count: 0. Adding 1'), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Adding', "Key: {$asset_handle}, Handle: {$asset_handle}, src: {$asset_src}"), 1, $group_name);
		$this->expectLog('debug', array('add_', 'Exiting.', 'count: 1'), 1, $group_name);

		$this->instance->add_assets($assets_data, 'script');

		// Assert that inline_assets array is empty after add_assets and before register_assets is called
		$this->assertEmpty($this->instance->get_internal_inline_assets_array(), 'Inline assets array should be empty before register_assets call.');

		// Mock wp_script_is to indicate the asset is already registered
		// Called once in _process_single_asset, once in _process_inline_assets
		\WP_Mock::userFunction('wp_script_is')
			->times(2)
			->with($asset_handle, 'registered')
			->andReturn(true)
			->ordered($group_name);

		// Mock wp_script_is for 'enqueued' check within _process_inline_assets
		// This should NOT be called if 'registered' is true due to short-circuiting in the IF condition.
		\WP_Mock::userFunction('wp_script_is')
			->never()
			->with($asset_handle, 'enqueued')
			->ordered($group_name);

		// Expect wp_register_script NOT to be called
		\WP_Mock::userFunction('wp_register_script')
			->never()
			->ordered($group_name);

		// Expect the specific debug log messages in order
		// From _process_single_asset
		$this->expectLog('debug', array('_process_single_asset', 'Processing', "'{$asset_handle}'"), 1, $group_name);
		$this->expectLog('debug', array('_process_single_asset', "'{$asset_handle}' already registered. Skipping"), 1, $group_name);

		// From _process_inline_assets (called by _process_single_asset)
		$this->expectLog('debug', array('_process_inline_', 'Checking for',  "parent handle '{$asset_handle}'."), 1, $group_name);
		$this->expectLog('debug', array('_process_inline_', 'No inline', "found or processed for '{$asset_handle}'."), 1, $group_name);

		// From _process_single_asset (finish)
		$this->expectLog('debug', array('_process_single_asset', 'Finished processing', "'{$asset_handle}'."), 1, $group_name);

		// Act: register_assets will call _process_single_asset with $do_register = true
		$this->instance->register_assets();

		// Assert: Mockery and WP_Mock will verify expectations.
		$this->assertTrue(true); // Placeholder assertion
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * Tests that _process_single_asset logs and skips enqueueing if a asset is already enqueued.
	 */
	public function test_process_single_asset_logs_when_asset_already_enqueued_and_skips_re_enqueue(): void {
		// Arrange
		$sut = $this->instance;

		$asset_handle       = 'my-already-enqueued-asset';
		$hook_name          = 'my_custom_hook';
		$processing_context = 'test_context';
		$asset_definition   = array(
			'handle' => $asset_handle,
			'src'    => 'path/to/asset.js',
		);

		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->zeroOrMoreTimes()->andReturn(true);
		$this->logger_mock->shouldIgnoreMissing();
		$group_name = 'process_single_asset';

		// Mock WordPress functions
		\WP_Mock::userFunction('wp_script_is', array(
			'args'   => array($asset_handle, 'registered'),
			'return' => true,
		))->ordered($group_name);
		\WP_Mock::userFunction('wp_script_is', array(
			'args'   => array($asset_handle, 'enqueued'),
			'return' => true,
		))->ordered($group_name);

		// Ordered expectations ONLY for is_active calls (when hook_name is NOT null, inline processing in _process_single_asset is skipped)
		$this->expectLog('debug', array('_process_single_asset', 'Processing', "'{$asset_handle}' on hook '{$hook_name}' in context '{$processing_context}'"), 1, $group_name);
		$this->expectLog('debug', array('_process_single_asset', "Script '{$asset_handle}' on hook '{$hook_name}' already enqueued. Skipping wp_enqueue_script."), 1, $group_name);
		$this->expectLog('debug', array('_process_single_asset', "Script '{$asset_handle}' on hook '{$hook_name}' already registered. Skipping wp_register_script."), 1, $group_name);
		$this->expectLog('debug', array('_process_single_asset', 'Finished processing', "'{$asset_handle}' on hook '{$hook_name}'."), 1, $group_name);

		// Act
		$reflection = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_single_asset');
		$reflection->setAccessible(true);
		$result = $reflection->invoke(
			$sut,
			$asset_definition,
			$processing_context,
			$hook_name,
			true, // do_register
			true  // do_enqueue
		);

		// Assert
		$this->assertSame($asset_handle, $result, 'Method should return the handle on success.');
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * Tests that _process_single_asset returns false for an invalid asset definition.
	 */
	public function test_process_single_asset_returns_false_for_invalid_definition(): void {
		// Arrange
		$sut              = $this->instance;
		$asset_definition = array(
			'handle' => 'my-invalid-asset',
			'src'    => '', // Invalid src makes it invalid when do_register is true
		);
		$hook_name          = 'test_hook';
		$processing_context = 'test_context';
		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->zeroOrMoreTimes()->andReturn(true);
		$this->logger_mock->shouldIgnoreMissing();
		$group_name = 'process_single_asset';

		$this->expectLog('debug', array('_process_single_asset', 'Processing', "{$asset_definition['handle']}' on hook '{$hook_name}' in context '{$processing_context}'"), 1, $group_name);
		$this->expectLog('warning', array('_process_single_asset', "Missing handle or src. Skipping. Handle: '{$asset_definition['handle']}' on hook '{$hook_name}'."), 1, $group_name);

		// Act
		$reflection = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_single_asset');
		$reflection->setAccessible(true);
		$result = $reflection->invoke(
			$sut,
			$asset_definition,
			$processing_context,
			$hook_name,
			true,  // do_register
			false  // do_enqueue
		);

		// Assert
		$this->assertFalse($result);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * Tests that _process_single_asset returns false when wp_register_script fails.
	 */
	public function test_process_single_asset_returns_false_on_registration_failure(): void {
		// Arrange
		$sut                = $this->instance;
		$asset_handle       = 'my-failing-asset';
		$hook_name          = 'test_hook';
		$processing_context = 'test_context';

		$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->zeroOrMoreTimes()->andReturn(true);
		$this->logger_mock->shouldIgnoreMissing();
		$group_name = 'process_single_asset';

		$asset_definition = array(
			'handle' => $asset_handle,
			'src'    => 'path/to/asset.js',
		);

		\WP_Mock::userFunction('wp_script_is', array(
			'args'   => array($asset_handle, 'registered'),
			'return' => false,
			'times'  => 1,
		))->ordered($group_name);

		\WP_Mock::userFunction('wp_register_script', array(
			'args' => array(
				$asset_handle,
				$asset_definition['src'],
				array(),      // deps
				false,   // version
				false    // in_footer
			),
			'return' => false, // Simulate failure
			'times'  => 1,
		))->ordered($group_name);

		$this->expectLog('warning', array('_process_single_asset', "wp_register_script() failed for handle '{$asset_handle}' on hook '{$hook_name}'. Skipping further processing for this asset."), 1, $group_name);

		// Act
		$reflection = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_single_asset');
		$reflection->setAccessible(true);
		$result = $reflection->invoke(
			$sut,
			$asset_definition,
			$processing_context,
			$hook_name,
			true,  // do_register
			false  // do_enqueue
		);

		// Assert
		$this->assertFalse($result);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_process_inline_assets_handles_deferred_asset_with_matching_hook(): void {
		// Arrange
		$sut           = $this->instance;
		$parent_handle = 'parent-asset';
		$hook_name     = 'a_custom_hook';
		$inline_asset  = array(
			'handle'      => $parent_handle,
			'content'     => '.my-class { color: red; }',
			'parent_hook' => $hook_name,
			'position'    => 'after',
		);
		$reflection = new \ReflectionObject($sut);
		$property   = $reflection->getProperty('inline_assets');
		$property->setAccessible(true);
		$property->setValue($sut, array($inline_asset));
		$group_name = 'deferred';

		// The order of mock expectations must match the order of execution in the SUT.
		// 1. Log "Checking..."
		$this->expectLog('debug', "ScriptsEnqueueTrait::_process_inline_assets (context: deferred) - Checking for inline assets for parent handle 'parent-asset' on hook 'a_custom_hook'.", 1, $group_name);

		// 2. wp_script_is() is called. Because it returns true, the second call is short-circuited.
		WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'registered')->andReturn(true)->once()->ordered($group_name);

		// 3. Log "Adding..."
		$this->expectLog('debug', "ScriptsEnqueueTrait::_process_inline_assets (context: deferred) - Adding inline asset for 'parent-asset' (key: 0, position: after) on hook 'a_custom_hook'.", 1, $group_name);

		// 4. wp_add_inline_script() is called and must return true for the asset to be marked as processed.
		WP_Mock::userFunction('wp_add_inline_script')->with('parent-asset', '.my-class { color: red; }', 'after')->andReturn(true)->once()->ordered($group_name);

		// 5. Log "Successfully added..."
		$this->expectLog('debug', "ScriptsEnqueueTrait::_process_inline_assets (context: deferred) - Successfully added inline asset for 'parent-asset' with wp_add_inline_script.", 1, $group_name);

		// 6. Log "Removed..." - This is the final log message we need to see.
		$this->expectLog('debug', "ScriptsEnqueueTrait::_process_inline_assets (context: deferred) - Removed processed inline asset with key '0' for handle 'parent-asset' on hook 'a_custom_hook'.", 1, $group_name);

		// Act
		$reflection = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_inline_assets');
		$reflection->setAccessible(true);
		$reflection->invoke($sut, $parent_handle, $hook_name, 'deferred');

		WP_Mock::assertActionsCalled();
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_process_inline_assets_skips_style_when_condition_is_false(): void {
		// Arrange
		$sut           = $this->instance;
		$parent_handle = 'parent-asset';
		$inline_asset  = array(
			'handle'    => $parent_handle,
			'content'   => '.my-class { color: blue; }',
			'condition' => fn() => false,
		);
		$reflection = new \ReflectionObject($sut);
		$property   = $reflection->getProperty('inline_assets');
		$property->setAccessible(true);
		$property->setValue($sut, array($inline_asset));

		$group_name = 'immediate';
		WP_Mock::userFunction('wp_script_is')->with($parent_handle, 'registered')->andReturn(true)->once()->ordered($group_name);

		$this->expectLog('debug', "ScriptsEnqueueTrait::_process_inline_assets (context: immediate) - Checking for inline assets for parent handle 'parent-asset'.", 1, $group_name);
		$this->expectLog('debug', "ScriptsEnqueueTrait::_process_inline_assets (context: immediate) - Condition false for inline asset targeting 'parent-asset' (key: 0).", 1, $group_name);
		WP_Mock::userFunction('wp_add_inline_script')->never()->ordered($group_name);

		// Act
		$reflection = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_inline_assets');
		$reflection->setAccessible(true);
		$reflection->invoke($sut, $parent_handle, null, 'immediate');

		WP_Mock::assertActionsCalled();
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_inline_assets
	 */
	public function test_process_inline_assets_skips_asset_with_empty_content(): void {
		// Arrange
		$sut           = $this->instance;
		$parent_handle = 'parent-asset';
		$inline_asset  = array(
			'handle'  => $parent_handle,
			'content' => '', // Empty content
		);
		$reflection = new \ReflectionObject($sut);
		$property   = $reflection->getProperty('inline_assets');
		$property->setAccessible(true);
		$property->setValue($sut, array($parent_handle => array($inline_asset)));

		// We don't expect any logging for this case in the refactored code.
		$this->logger_mock->shouldNotReceive('warning');

		// wp_add_inline_script should never be called.
		WP_Mock::userFunction('wp_add_inline_script')->never();

		// Act
		$reflection = new \ReflectionMethod(ConcreteEnqueueForScriptsTesting::class, '_process_inline_assets');
		$reflection->setAccessible(true);
		$reflection->invoke($sut, $parent_handle, null, 'immediate');

		// Assert
		WP_Mock::assertActionsCalled(); // This will fail if wp_add_inline_script was called.
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetTraitBase::enqueue_assets
	 */
	public function test_enqueue_assets_throws_exception_for_deferred_style_in_queue(): void {
		// Arrange
		$sut = $this->instance;

		$deferred_asset = array(
			'handle' => 'deferred-asset',
			'src'    => 'path/to/asset.js',
			'hook'   => 'wp_footer',
		);

		$reflection = new \ReflectionObject($sut);
		$property   = $reflection->getProperty('assets');
		$property->setAccessible(true);
		$property->setValue($sut, array($deferred_asset));

		// Expect
		$this->expectException(\LogicException::class);
		$this->expectExceptionMessage(
			"Ran\PluginLib\EnqueueAccessory\EnqueueAssetTraitBase::enqueue_scripts - Found a deferred asset ('deferred-asset') in the immediate queue. The `register_assets()` method must be called before `enqueue_assets()` to correctly process deferred assets."
		);

		// Act
		$sut->enqueue_assets();
	}

	// region Process Single Script Tests
	// ==========================================================================
	// Tests for the _process_single_asset method, covering various scenarios
	// including registration, enqueuing, conditional loading, and extras.
	// ==========================================================================

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 * @dataProvider provide_process_single_asset_cases
	 */
	public function skip_test_process_single_asset(
		array $asset_def,
		string $context,
		?string $hook_name,
		bool $do_register,
		bool $do_enqueue,
		$expected_result,
		array $wp_mock_expects,
		array $logger_expects
	): void {
		// Set up logger expectations
		if (!empty($logger_expects)) {
			$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);
			foreach ($logger_expects as $expectation) {
				if (!is_array($expectation) || count($expectation) < 2) {
					throw new InvalidArgumentException('Each log expectation must be an array with at least a level and a message array.');
				}
				// Unpack all parameters, providing default values
				$level       = $expectation[0];
				$messages    = $expectation[1];
				$times       = $expectation[2] ?? 1;
				$order_group = $expectation[3] ?? null;
				$debug       = $expectation[4] ?? false;

				$this->expectLog($level, $messages, $times, $order_group, $debug);
			}
		} else {
			$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(false);
		}

		$this->_setup_wp_mocks($wp_mock_expects);

		$result = $this->_invoke_protected_method($this->instance, '_process_single_asset', array($asset_def, $context, $hook_name, $do_register, $do_enqueue));
		$this->assertSame($expected_result, $result);
	}

	public static function provide_process_single_asset_cases(): array {
		return array(
			'basic_registration_success' => array(
				'asset_def'       => array('handle' => 'test-handle', 'src' => 'test.js', 'deps' => array(), 'version' => false, 'in_footer' => false),
				'context'         => 'test_context_reg',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => false,
				'expected_result' => 'test-handle',
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						'args'   => array('test-handle', 'registered'),
						'return' => array(false, true),
						'times'  => 2,
					),
					'wp_register_script' => array(
						'args'   => array('test-handle', 'test.js', array(), false, false),
						'return' => true,
						'times'  => 1,
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'test-handle'", 'test_context_reg'), 1, null),
					array('debug', array('_process_single_', 'Registering', "'test-handle'"), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'Checking for inline assets', 'test-handle'), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'No inline assets found', 'test-handle'), 1, null, false),
					array('debug', array('_process_single_', 'Finished processing', "'test-handle'"), 1, null, false),
				),
			),
			'basic_enqueue_success' => array(
				'asset_def'       => array('handle' => 'test-handle', 'src' => 'test.js', 'deps' => array('jquery'), 'version' => '1.0', 'in_footer' => true),
				'context'         => 'test_context_reg_enq',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => true,
				'expected_result' => 'test-handle',
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						// First expectation for wp_script_is
						array(
							'args'   => array('test-handle', 'registered'),
							'return' => array(false, true),
							'times'  => 2,
						),
						// Second expectation for wp_script_is
						array(
							'args'   => array('test-handle', 'enqueued'),
							'return' => false,
							'times'  => 1,
						),
					),
					'wp_register_script' => array(
						// Single expectation for wp_register_script
						'args'   => array('test-handle', 'test.js', array('jquery'), '1.0', true),
						'return' => true,
						'times'  => 1,
					),
					'wp_enqueue_script' => array(
						// Single expectation for wp_enqueue_script
						'args'   => array('test-handle'),
						'return' => null,
						'times'  => 1,
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'test-handle'", 'test_context_reg_enq'), 1, null, false),
					array('debug', array('_process_single_', 'Registering', "'test-handle'"), 1, null, false),
					array('debug', array('_process_single_', 'Enqueuing', "'test-handle'"), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'Checking for inline assets', 'test-handle'), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'No inline assets found', 'test-handle'), 1, null, false),
					array('debug', array('_process_single_', 'Finished processing', "'test-handle'"), 1, null, false),
				),
			),
			'already_registered_skips_registration' => array(
				'asset_def'       => array('handle' => 'test-handle', 'src' => 'test.js'),
				'context'         => 'test_context_already_reg',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => false,
				'expected_result' => 'test-handle',
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						'args'   => array('test-handle', 'registered'),
						'return' => true,
						'times'  => 2,
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'test-handle'", 'test_context_already_reg'), 1, null, false),
					array('debug', array('_process_single_', "Script 'test-handle' already registered"), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'Checking for inline assets', 'test-handle'), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'No inline assets found', 'test-handle'), 1, null, false),
					array('debug', array('_process_single_', 'Finished processing', "'test-handle'"), 1, null, false),
				),
			),
			'already_enqueued_skips_enqueuing' => array(
				'asset_def'       => array('handle' => 'test-handle', 'src' => 'test.js'),
				'context'         => 'test_context_already_enq',
				'hook_name'       => null,
				'do_register'     => true, // Assumes registration or already registered
				'do_enqueue'      => true,
				'expected_result' => 'test-handle',
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						array(
							'args'   => array('test-handle', 'registered'),
							'return' => true,
							'times'  => 2,
						),
						array(
							'args'   => array('test-handle', 'enqueued'),
							'return' => true,
							'times'  => 1,
						),
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'test-handle'", 'test_context_already_enq'), 1, null, false),
					array('debug', array('_process_single_', "Script 'test-handle' already registered"), 1, null, false),
					array('debug', array('_process_single_', "Script 'test-handle' already enqueued"), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'Checking for inline assets', 'test-handle'), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'No inline assets found', 'test-handle'), 1, null, false),
					array('debug', array('_process_single_', 'Finished processing', "'test-handle'"), 1, null, false),
				),
			),
			'condition_false_skips_processing' => array(
				'asset_def'       => array('handle' => 'test-handle', 'src' => 'test.js', 'condition' => static fn() => false),
				'context'         => 'test_context_cond_false',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => true,
				'expected_result' => false,
				'wp_mock_expects' => array(),
				'logger_expects'  => array(
					array('debug', array('_process_single_', 'Processing', "'test-handle'", 'test_context_cond_false'), 1, null),
					array('debug', array('_process_single_', 'Condition not met for', "'test-handle'", 'Skipping.'), 1, null),
				),
			),
			'missing_handle_returns_false' => array(
				'asset_def'       => array('src' => 'test.js'), // Missing handle
				'context'         => 'test_context_no_handle',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => false,
				'expected_result' => false,
				'wp_mock_expects' => array(),
				'logger_expects'  => array(
					array('debug', array('_process_single_', 'Processing', "'N/A'", 'test_context_no_handle'), 1, null),
					array('warning', array('_process_single_', 'Invalid', "Handle: 'N/A'"), 1, null),
				),
			),
			'missing_src_when_registering_returns_false' => array(
				'asset_def'       => array('handle' => 'test-handle'), // Missing src
				'context'         => 'test_context_no_src',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => false,
				'expected_result' => false,
				'wp_mock_expects' => array(),
				'logger_expects'  => array(
					array('debug', array('_process_single_', 'Processing', "'test-handle'", 'test_context_no_src'), 1, null, false),
					array('warning', array('_process_single_', 'Invalid', "Handle: 'test-handle'")),
				),
			),
			'registration_failure_returns_false' => array(
				'asset_def'       => array('handle' => 'test-handle', 'src' => 'test.js'),
				'context'         => 'test_context_reg_fail',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => false,
				'expected_result' => false,
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						'args'   => array('test-handle', 'registered'),
						'return' => false,
						'times'  => 1,
					),
					'wp_register_script' => array(
						'args'   => array('test-handle', 'test.js', array(), false, false),
						'return' => false,
						'times'  => 1,
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'test-handle'", 'test_context_reg_fail'), 1, null, false),
					array('debug', array('_process_single_', 'Registering', "'test-handle'"), 1, null, false),
					array('warning', array('_process_single_', "wp_register_script() failed for handle 'test-handle'")),
				),
			),
			'defer_attribute_routing' => array(
				'asset_def'       => array('handle' => 'defer-handle', 'src' => 'defer.js', 'attributes' => array('defer' => true)),
				'context'         => 'test_context_defer_route',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => true,
				'expected_result' => 'defer-handle',
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						array('args' => array('defer-handle', 'registered'), 'return' => false, 'times' => 1),
						array('args' => array('defer-handle', 'enqueued'), 'return' => false, 'times' => 1),
						array('args' => array('defer-handle', 'registered'), 'return' => true, 'times' => 1),
					),
					'wp_register_script' => array(
						'args'   => array('defer-handle', 'defer.js', array(), false, false),
						'return' => true,
						'times'  => 1,
					),
					'wp_script_add_data' => array(
						'args'   => array('defer-handle', 'strategy', 'defer'),
						'return' => true,
						'times'  => 1,
					),
					'wp_enqueue_script' => array(
						'args'   => array('defer-handle'),
						'return' => null,
						'times'  => 1,
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'defer-handle'", 'test_context_defer_route'), 1, null, false),
					array('debug', array('_process_single_', 'Registering', "'defer-handle'"), 1, null, false),
					array('debug', array('_process_single_', "Routing 'defer' attribute for 'defer-handle'"), 1, null, false),
					array('debug', array('_process_single_', 'Enqueuing', "'defer-handle'"), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'Checking for inline assets', 'defer-handle'), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'No inline assets found', 'defer-handle'), 1, null, false),
					array('debug', array('_process_single_', 'Finished processing', "'defer-handle'"), 1, null, false),
				),
			),
			'async_and_custom_attribute_routing' => array(
				'asset_def'       => array('handle' => 'async-custom-handle', 'src' => 'ac.js', 'attributes' => array('async' => true, 'data-foo' => 'bar')),
				'context'         => 'test_context_async_custom_route',
				'hook_name'       => null,
				'do_register'     => true,
				'do_enqueue'      => true,
				'expected_result' => 'async-custom-handle',
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						array('args' => array('async-custom-handle', 'registered'), 'return' => false, 'times' => 1),
						array('args' => array('async-custom-handle', 'enqueued'), 'return' => false, 'times' => 1),
						array('args' => array('async-custom-handle', 'registered'), 'return' => true, 'times' => 1),
					),
					'wp_register_script' => array(
						'args'   => array('async-custom-handle', 'ac.js', array(), false, false),
						'return' => true,
						'times'  => 1,
					),
					'wp_script_add_data' => array(
						'args'   => array('async-custom-handle', 'strategy', 'async'),
						'return' => true,
						'times'  => 1,
					),
					'wp_enqueue_script' => array(
						'args'   => array('async-custom-handle'),
						'return' => null,
						'times'  => 1,
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'async-custom-handle'", 'test_context_async_custom_route'), 1, null, false),
					array('debug', array('_process_single_', 'Registering', "'async-custom-handle'"), 1, null, false),
					array('debug', array('_process_single_', "Routing 'async' attribute for 'async-custom-handle'", "wp_script_add_data('strategy', 'async')"), 1, null, false),
					array('debug', array('_process_single_', 'Enqueuing', "'async-custom-handle'"), 1, null, false),
					array('debug', array('_process_single_', 'Adding attributes for', "'async-custom-handle'", 'script_loader_tag', '{"data-foo":"bar"}'), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'Checking for inline', 'async-custom-handle'), 1, null, false),
					array('debug', array('_process_inline_', 'immediate_after_registration', 'No inline', 'async-custom-handle'), 1, null, false),
					array('debug', array('_process_single_', 'Finished processing', "'async-custom-handle'"), 1, null, false),
				),
			),
			'deferred_context_skips_extras' => array(
				'asset_def'       => array('handle' => 'deferred-handle', 'src' => 'deferred.js', 'attributes' => array('data-test' => 'value'), 'wp_data' => array('key' => 'val')),
				'context'         => 'test_context_deferred',
				'hook_name'       => 'some_hook',
				'do_register'     => true,
				'do_enqueue'      => true,
				'expected_result' => 'deferred-handle',
				'wp_mock_expects' => array(
					'wp_script_is' => array(
						array('args' => array('deferred-handle', 'registered'), 'return' => false, 'times' => 1),
						array('args' => array('deferred-handle', 'enqueued'), 'return' => false, 'times' => 1),
					),
					'wp_register_script' => array(
						'args'   => array('deferred-handle', 'deferred.js', array(), false, false),
						'return' => true,
						'times'  => 1,
					),
					'wp_enqueue_script' => array(
						'args'   => array('deferred-handle'),
						'return' => null,
						'times'  => 1,
					),
				),
				'logger_expects' => array(
					array('debug', array('_process_single_', 'Processing', "'deferred-handle' on hook 'some_hook'", 'test_context_deferred'), 1, null, false),
					array('debug', array('_process_single_', 'Registering', "'deferred-handle' on hook 'some_hook'"), 1, null, false),
					array('debug', array('_process_single_', 'Enqueuing', "'deferred-handle' on hook 'some_hook'"), 1, null, false),
					array('debug', array('_process_single_', 'Finished processing', "'deferred-handle' on hook 'some_hook'"), 1, null, false),
				),
			),
		);
	}

	// endregion Process Single Script Tests

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 */
	public function test_process_single_asset_handles_registration_failure(): void {
		$asset_def = array('handle' => 'fail-handle', 'src' => 'fail.js');

		WP_Mock::userFunction('wp_script_is')->with('fail-handle', 'registered')->andReturn(false);
		WP_Mock::userFunction('wp_register_script')->with('fail-handle', 'fail.js', array(), false, false)->andReturn(false);

		$this->expectLog('warning', array('_process_single_asset', "failed for handle 'fail-handle'. Skipping further processing for this asset."), 1, 'test_context');

		$result = $this->_invoke_protected_method($this->instance, '_process_single_asset', array($asset_def, 'test_context', null, true, false));

		$this->assertFalse($result);
	}

	/**
	 * @test
	 * @dataProvider provide_add_data_failure_scenarios
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 */
	public function skip_test_process_single_asset_logs_warning_on_add_data_failure(string $strategy): void {
		$handle    = "{$strategy}-fail-handle";
		$asset_def = array('handle' => $handle, 'src' => 'fail.js', 'attributes' => array($strategy => true));

		WP_Mock::userFunction('wp_script_is')->with($handle, 'registered')->andReturn(false);
		WP_Mock::userFunction('wp_script_is')->with($handle, 'enqueued')->andReturn(false);
		WP_Mock::userFunction('wp_register_script')->andReturn(true);
		WP_Mock::userFunction('wp_script_add_data')->with($handle, 'strategy', $strategy)->andReturn(false);

		$this->expectLog('warning', array('_process_single_', "Failed to add '{$strategy}' strategy for '{$handle}'"), 1, 'test_context');

		$result = $this->_invoke_protected_method($this->instance, '_process_single_asset', array($asset_def, 'test_context', null, true, false));
		$this->assertSame($handle, $result);
	}

	/**
	 * Data provider for `test_process_single_asset_logs_warning_on_add_data_failure`.
	 *
	 * @return array
	 */
	public function provide_add_data_failure_scenarios(): array {
		return array(
			'async failure' => array('async'),
			'defer failure' => array('defer'),
		);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 */
	public function test_process_single_asset_ignores_src_attribute(): void {
		$asset_def = array('handle' => 'src-ignore-handle', 'src' => 'original.js', 'attributes' => array('src' => 'ignored.js'));

		WP_Mock::userFunction('wp_script_is')->andReturn(false);
		WP_Mock::userFunction('wp_register_script')->with('src-ignore-handle', 'original.js', array(), false, false)->andReturn(true)->once();

		$this->logger_mock->shouldReceive('debug')
			->with("ScriptsEnqueueTrait::_process_single_asset - Ignoring 'src' attribute for 'src-ignore-handle' as it is managed by WordPress during registration.")
			->once();

		$result = $this->_invoke_protected_method($this->instance, '_process_single_asset', array($asset_def, 'test_context', null, true, false));
		$this->assertSame('src-ignore-handle', $result);
	}

	/**
	 * @test
	 * @dataProvider provide_invalid_asset_definitions
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_process_single_asset
	 */
	public function skip_test_process_single_asset_handles_invalid_definition(array $asset_def, string $expected_log_handle):void {
		$this->expectLog('warning', array('_process_single_', "Missing handle or src. Skipping. Handle: '{$expected_log_handle}'."), 1, 'test_context');

		$result = $this->_invoke_protected_method($this->instance, '_process_single_asset', array($asset_def, 'test_context', null, true, false));

		$this->assertFalse($result);
	}

	/**
	 * Data provider for `test_process_single_asset_with_invalid_definition`.
	 *
	 * Provides asset definitions that are missing required keys (`handle` or `src`).
	 *
	 * @return array
	 */
	public function provide_invalid_asset_definitions(): array {
		return array(
			'missing handle' => array(array('src' => 'some.js'), 'N/A'),
			'missing src'    => array(array('handle' => 'no-src-handle'), 'no-src-handle'),
		);
	}


	// region Script-Specific Attribute and Processing Tests
	// ==========================================================================
	// The following tests are specific to ScriptsEnqueueTrait and cover methods
	// like _modify_html_tag_attributes and aspects of _process_single_asset
	// that do not have direct equivalents in StylesEnqueueTrait.
	// ==========================================================================

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_modify_html_tag_attributes
	 * @dataProvider provide_asset_tag_modification_cases
	 */
	public function skip_test_modify_html_tag_attributes(string $original_tag, string $handle, array $attributes, string $expected_tag, ?array $logger_expects = null): void {
		if (!empty($logger_expects)) {
			$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(true);

			foreach ($logger_expects as $log_level => $messages_for_level) {
				// This handles the case where multiple calls are defined for the same log level.
				// e.g., 'debug' => array( array('msg1_part1', 'msg1_part2'), array('msg2') )
				if (isset($messages_for_level[0]) && is_array($messages_for_level[0])) {
					foreach ($messages_for_level as $log_arguments) {
						// Pass the entire array of substrings to create a specific expectation.
						$this->expectLog($log_level, $log_arguments);
					}
				} else {
					// This handles a single call for a log level where the arguments are not nested.
					// e.g., 'warning' => array('warn_msg_part1', 'warn_msg_part2')
					if (!empty($messages_for_level)) {
						$this->expectLog($log_level, $messages_for_level);
					}
				}
			}
		} else {
			$this->logger_mock->shouldReceive('is_active')->withAnyArgs()->andReturn(false);
		}

		$modified_tag = $this->_invoke_protected_method($this->instance, '_modify_html_tag_attributes', array($original_tag, $handle, $handle, $attributes));
		$this->assertEquals($expected_tag, $modified_tag);
	}

	/**
	 * Data provider for `test_modify_html_tag_attributes`.
	 *
	 * @return array
	 */
	public static function provide_asset_tag_modification_cases(): array {
		$complex_attrs        = array('type' => 'module', 'async' => true, 'defer' => false, 'data-version' => '1.2', 'integrity' => 'sha384-xyz', 'crossorigin' => 'anonymous', 'custom-empty' => '');
		$complex_expected_tag = '<script type="module" id="main-asset" src="./app.js?v=1.2" async data-version="1.2" integrity="sha384-xyz" crossorigin="anonymous"></script>';

		return array(
			'basic_async' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('async' => true),
				'<script src="test.js" async></script>',
				null
			),
			'basic_defer' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('defer' => true),
				'<script src="test.js" defer></script>',
				null
			),
			'type_module' => array(
				'<script src="module.js"></script>',
				'module-handle',
				array('type' => 'module'),
				'<script type="module" src="module.js"></script>',
				array(
					'debug' => array(
						array(
							'_modify_html_tag_attributes -', "Modifying tag for handle 'module-handle'. Attributes: " . json_encode(array('type' => 'module'))
						),
						array(
							'_modify_html_tag_attributes -', "Script 'module-handle' is a module. Modifying tag accordingly."
						),
						array(
							'_modify_html_tag_attributes -', "Successfully modified tag for 'module-handle'. New tag: " . esc_html('<script type="module" src="module.js"></script>')
						)
					)
				)
			),
			'custom_attribute' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('data-custom' => 'my-value'),
				'<script src="test.js" data-custom="my-value"></script>',
				null
			),
			'multiple_attributes' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('async' => true, 'defer' => true, 'data-id' => '123'),
				'<script src="test.js" async defer data-id="123"></script>',
				null
			),
			'src_attribute_ignored' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('src' => 'ignored.js', 'async' => true),
				'<script src="test.js" async></script>',
				array(
					'debug' => array(
						array(
							'_modify_html_tag_attributes -',
							'Modifying tag for handle',
							'test-handle',
							'{"src":"ignored.js","async":true}'
						),
						array(
							'_modify_html_tag_attributes -',
							'Successfully modified tag for',
							'test-handle',
							'<script src="test.js" async>'
						)
					),
					'warning' => array(
						array(
							'_modify_html_tag_attributes -',
							"Attempt to override managed attribute 'src'",
							"for script handle 'test-handle'",
							'. This attribute will be ignored.'
						)
					)
				)
			),
			'false_attribute_skipped' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('async' => false, 'data-id' => '123'),
				'<script src="test.js" data-id="123"></script>',
				null
			),
			'null_attribute_skipped' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('defer' => null, 'data-id' => '123'),
				'<script src="test.js" data-id="123"></script>',
				null
			),
			'empty_string_attribute_skipped' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('data-custom' => '', 'data-id' => '123'),
				'<script src="test.js" data-id="123"></script>',
				null
			),
			'malformed_tag_no_closing_bracket' => array(
				'<script src="test.js"', // Malformed
				'test-handle',
				array('async' => true),
				'<script src="test.js"', // Expect original tag
				array(
					'debug' => array(
						array(
							'_modify_html_tag_attributes -', "Modifying tag for handle 'test-handle'. Attributes: " . json_encode(array('async' => true))
						)
					),
					'warning' => array(
						array(
							'_modify_html_tag_attributes -', "Malformed script tag for 'test-handle'. Original tag: " . esc_html('<script src="test.js"') . '. Skipping attribute modification.'
						)
					)
				)
			),
			'malformed_tag_no_asset_opening' => array(
				'<div></div>', // Malformed
				'test-handle',
				array('async' => true),
				'<div></div>', // Expect original tag
				array(
					'debug' => array(
						array(
							'_modify_html_tag_attribute', "Modifying tag for handle 'test-handle'. Attributes: {\"async\":true}"
						)
					),
					'warning' => array(
						array(
							'_modify_html_tag_attributes -', "Malformed script tag for 'test-handle'. Original tag: " . esc_html('<div></div>') . '. Skipping attribute modification.'
						)
					)
				)
			),
			'attribute_value_escaping' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('data-value' => 'needs "escaping" & stuff'),
				'<script src="test.js" data-value="needs &quot;escaping&quot; &amp; stuff"></script>',
				null
			),
			'empty_attributes_array_returns_original_tag' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array(), // attributes
				'<script src="test.js"></script>', // expected_tag
				array( // Expected logger calls
					'debug' => array(
						array(
							'_modify_html_tag_attributes -', "Successfully modified tag for 'test-handle'. New tag: " . esc_html('<script src="test.js"></script>')
						)
					)
				)
			),
			'attribute_with_zero_integer_value' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('data-count' => 0),
				'<script src="test.js" data-count="0"></script>',
				array(
					'debug' => array(
						array('_modify_html_tag_attributes -', "Modifying tag for handle 'test-handle'. Attributes: {\"data-count\":0}"),
						array('_modify_html_tag_attributes -', "Successfully modified tag for 'test-handle'. New tag: " . esc_html('<script src="test.js" data-count="0"></script>'))
					)
				)
			),
			'attribute_with_zero_string_value' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('data-count' => '0'),
				'<script src="test.js" data-count="0"></script>',
				array(
					'debug' => array(
						array('_modify_html_tag_attributes -', "Modifying tag for handle 'test-handle'. Attributes: {\"data-count\":\"0\"}"),
						array('_modify_html_tag_attributes -', "Successfully modified tag for 'test-handle'. New tag: " . esc_html('<script src="test.js" data-count="0"></script>'))
					)
				)
			),
			'wp_managed_attribute_id_ignored' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('id' => 'new-id', 'async' => true),
				'<script src="test.js" async></script>',
				array(
					'debug' => array(
						array(
							'_modify_html_tag_attributes -',
							'Modifying tag for handle',
							'test-handle',
							'{"id":"new-id","async":true}'
						),
						array(
							'_modify_html_tag_attributes -',
							'Successfully modified tag for',
							'test-handle',
							'<script src="test.js" async>'
						)
					),
					'warning' => array(
						array(
							'_modify_html_tag_attributes -',
							"Attempt to override managed attribute 'id'",
							"for script handle 'test-handle'",
							'. This attribute will be ignored.'
						)
					)
				)
			),
            'wp_managed_attribute_id_ignored_logger_inactive' => array(
                '<script src="test.js"></script>',
                'test-handle',
                array('id' => 'new-id', 'async' => true),
                '<script src="test.js" async></script>',
                array()
            ),
			'All attributes are ignored' => array(
				'<script src="test.js"></script>',
				'test-handle',
				array('src' => 'ignored.js', 'id' => 'new-id'),
				'<script src="test.js"></script>',
				array(
					'debug' => array(
						array(
							'_modify_html_tag_attributes -',
							'Modifying tag for handle',
							'test-handle',
							'{"src":"ignored.js","id":"new-id"}'
						),
						array(
							'_modify_html_tag_attributes -',
							'Successfully modified tag for',
							'test-handle',
							'<script src="test.js">'
						)
					),
					'warning' => array(
						array(
							'_modify_html_tag_attributes -',
							"Attempt to override managed attribute 'src'",
							"for script handle 'test-handle'",
							'. This attribute will be ignored.'
						),
						array(
							'_modify_html_tag_attributes -',
							"Attempt to override managed attribute 'id'",
							"for script handle 'test-handle'",
							'. This attribute will be ignored.'
						)
					)
				)
			),
			'complex_case_with_module_and_various_attrs' => array(
				'<script id="main-asset" src="./app.js?v=1.2"></script>',
				'app-main',
				$complex_attrs,
				$complex_expected_tag,
				array(
					'debug' => array(
						array('_modify_html_tag_attributes', 'Modifying tag for handle \'app-main\'. Attributes: ' . json_encode($complex_attrs)),
						array('_modify_html_tag_attributes', 'Script \'app-main\' is a module. Modifying tag accordingly.'),
						array('_modify_html_tag_attributes', 'Successfully modified tag for \'app-main\'. New tag: ' . esc_html($complex_expected_tag)),
					)
				)
			),
			'type_module_logger_inactive' => array(
				'<script src="module.js"></script>',
				'module-handle',
				array('type' => 'module'),
				'<script type="module" src="module.js"></script>',
				array() // Expect no logger calls
			),
			'malformed_tag_logger_inactive' => array(
				'<script src="test.js"', // Malformed
				'test-handle',
				array('async' => true),
				'<script src="test.js"', // Expect original tag
				array() // Expect no logger calls
			),
		);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait::_modify_html_tag_attributes
	 */
	public function test_modify_html_tag_attributes_returns_unmodified_on_handle_mismatch(): void {
		$original_tag          = '<script src="test.js"></script>';
		$filter_handle         = 'handle-being-filtered';
		$asset_handle_to_match = 'a-different-handle';
		$attributes            = array('async' => true);

		// The logger should not be called at all in this case, not even is_active.
		$this->logger_mock->shouldNotReceive('is_active');
		$this->logger_mock->shouldNotReceive('debug');
		$this->logger_mock->shouldNotReceive('warning');

		$result = $this->_invoke_protected_method(
			$this->instance,
			'_modify_html_tag_attributes',
			array($original_tag, $filter_handle, $asset_handle_to_match, $attributes)
		);

		$this->assertSame($original_tag, $result);
	}

	// endregion
}
