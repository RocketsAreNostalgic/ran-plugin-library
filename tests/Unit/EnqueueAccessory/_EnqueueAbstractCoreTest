<?php
declare(strict_types=1);

namespace Ran\PluginLib\Tests\Unit\EnqueueAccessory;

use Ran\PluginLib\Config\ConfigInterface;
use Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract;
use Ran\PluginLib\Tests\Unit\PluginLibTestCase;
use Ran\PluginLib\Util\Logger;
use Mockery;
use ReflectionProperty;
use WP_Mock;
use Ran\PluginLib\EnqueueAccessory\ScriptsEnqueueTrait;
use Ran\PluginLib\EnqueueAccessory\StylesEnqueueTrait;
use Ran\PluginLib\EnqueueAccessory\MediaEnqueueTrait;

/**
 * Concrete implementation of EnqueueAbstract for testing core methods.
 */
class ConcreteEnqueueForCoreTesting extends EnqueueAssetBaseAbstract {


	public function load(): void {
		// Mock implementation, does nothing for these tests.
	}

	// Expose protected properties for easier testing in this suite
	public function set_assets_for_testing(array $assets): void {
		$this->assets = $assets;
	}

	public function set_styles_for_testing(array $styles): void {
		$this->styles = $styles;
	}

	public function set_media_tool_configs_for_testing(array $media_configs): void {
		$this->media_tool_configs = $media_configs;
	}

	public function set_inline_assets_for_testing(array $inline_assets): void {
		$this->inline_assets = $inline_assets;
	}

	public function set_head_callbacks_for_testing(array $callbacks): void {
		$this->head_callbacks = $callbacks;
	}

	protected function _process_single_asset(
		array $asset_definition,
		string $processing_context,
		?string $hook_name = null,
		bool $do_register = true,
		bool $do_enqueue = false
	): string|false {
		// Mock implementation for testing.
		return $asset_definition['handle'] ?? false;
	}

	public function set_footer_callbacks_for_testing(array $callbacks): void {
		$this->footer_callbacks = $callbacks;
	}
}

/**
 * Class EnqueueAbstractCoreTest
 *
 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::enqueue
 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
 */
class EnqueueAbstractCoreTest extends PluginLibTestCase {
	// Properties $config_mock (ConcreteConfigForTesting) and $logger_mock (Mockery\MockInterface)
	// are now effectively inherited or will be correctly typed and populated.
	// We will ensure $this->logger_mock is a Mockery mock for setting expectations.
	protected ConcreteEnqueueForCoreTesting $sut;

	public function setUp(): void {
		parent::setUp(); // This sets up WP_Mock, config_mock, and logger_mock (the spy)
		WP_Mock::userFunction( '_doing_it_wrong' )->andReturnNull();

		// Instantiate the System Under Test (SUT) using the config mock from the parent.
		$this->sut = new ConcreteEnqueueForCoreTesting($this->config_mock);

		// Set up default permissive logging expectations on the logger spy.
		$this->logger_mock->shouldReceive('debug')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('info')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('warning')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('error')->withAnyArgs()->zeroOrMoreTimes()->andReturnNull()->byDefault();
		$this->logger_mock->shouldReceive('is_active')->withNoArgs()->zeroOrMoreTimes()->andReturn(true)->byDefault();
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::enqueue
	 */
	public function test_enqueue_processes_all_asset_types_when_present(): void {
		// 1. Create a mock config that will return our test logger.
		$local_config_mock = \Mockery::mock(ConfigInterface::class);
		$local_config_mock->shouldReceive('get_logger')->andReturn($this->logger_mock);

		// 2. Set precise logger expectations for the entire enqueue process.
		$this->expectLog('debug', array('EnqueueAssetTraitBase::enqueue_tests - Entered. Processing 1 test definition(s) from internal queue.'), 1, null, false);
		$this->expectLog('debug', array('EnqueueAssetTraitBase::enqueue_tests - Processing test: "N/A", original index: general.'), 1, null, false);
		$this->expectLog('debug', array('EnqueueAssetTraitBase::enqueue_tests - Exited. Deferred tests count: 0.'), 1, null, false);
		$this->expectLog('debug', array('StylesEnqueueTrait::enqueue_styles - Entered. Processing 1 style definition(s) from internal queue.'), 1, null, false);
		$this->expectLog('debug', array('StylesEnqueueTrait::enqueue_styles - Processing style: "N/A", original index: general.'), 1, null, false);
		$this->expectLog('debug', array("StylesEnqueueTrait::_process_single_style - Processing style 'N/A' in context 'enqueue_styles'."), 1, null, false);
		$this->expectLog('debug', array('StylesEnqueueTrait::enqueue_styles - Exited. Deferred styles count: 0.'), 1, null, false);
		$this->expectLog('debug', array('MediaEnqueueTrait::enqueue_media - Entered. Processing 1 media tool configuration(s).'), 1, null, false);
		$this->expectLog('debug', array('MediaEnqueueTrait::enqueue_media - Processing media tool configuration at original index: 0.'), 1, null, false);
		$this->expectLog('debug', array("MediaEnqueueTrait::enqueue_media - No hook specified for media tool configuration at original index 0. Defaulting to 'admin_enqueue_scripts'."), 1, null, false);
		$this->expectLog('debug', array('MediaEnqueueTrait::enqueue_media - Deferring media tool configuration at original index 0 to hook: "admin_enqueue_scripts".'), 1, null, false);
		$this->expectLog('debug', array("MediaEnqueueTrait::enqueue_media - Added action for 'enqueue_deferred_media_tools' on hook: \"admin_enqueue_scripts\"."), 1, null, false);
		$this->expectLog('debug', array('MediaEnqueueTrait::enqueue_media - Exited.'), 1, null, false);
		$this->expectLog('debug', array('EnqueueAssetTraitBase::enqueue_inline_tests - Entered method.'), 1, null, false);
		$this->expectLog('debug', array('EnqueueAssetTraitBase::enqueue_inline_tests - Found 1 unique parent handle(s) with immediate inline tests to process: test-script'), 1, null, false);
		$this->expectLog('debug', array("ScriptsEnqueueTrait::_process_inline_assets (context: enqueue_inline_tests) - Checking for inline assets for parent handle 'test-script'."), 1, null, false);
		$this->expectLog('debug', array('EnqueueAssetTraitBase::enqueue_inline_tests - Exited. Processed 1 parent handle(s). Remaining deferred inline tests: 0.'), 1, null, false);
		$this->expectLog('debug', array('EnqueueAssetBaseAbstract::enqueue - Main enqueue process finished.'), 1, null, false);

		// 3. Create a partial mock of the SUT. This calls the real constructor.
		/** @var \Mockery\MockInterface|ConcreteEnqueueForCoreTesting $sut */
		$sut = \Mockery::mock(ConcreteEnqueueForCoreTesting::class, array($local_config_mock))->makePartial();
		$sut->shouldAllowMockingProtectedMethods();

		// 4. Set expectations to verify trait methods are called, and allow them to run.
		$sut->shouldReceive('enqueue_assets')->once()->passthru();
		$sut->shouldReceive('enqueue_styles')->once()->passthru();
		$sut->shouldReceive('enqueue_media')->once()->passthru();
		$sut->shouldReceive('enqueue_inline_assets')->once()->passthru();

		// Mock all the WordPress functions that will be called.
		// Mock WordPress hooks for media enqueueing.
		WP_Mock::userFunction('has_action')
			->with('admin_enqueue_scripts', array( $sut, 'enqueue_deferred_media_tools' ))
			->andReturn(false);
		WP_Mock::userFunction('add_action')
			->with('admin_enqueue_scripts', array( $sut, 'enqueue_deferred_media_tools' ), 10, 0)
			->andReturn(true);

		// Mock script and style registration for asset processing.
		WP_Mock::userFunction('wp_script_is')->with('test-script', 'registered')->andReturn(false);
		WP_Mock::userFunction('wp_register_script')->with('test-script', false, array(), false, false)->andReturn(true);
		WP_Mock::userFunction('wp_script_is')->with('test-script', 'enqueued')->andReturn(false);
		WP_Mock::userFunction('wp_enqueue_script')->with('test-script')->andReturn(true);

		WP_Mock::userFunction('wp_style_is')->with('test-style', 'registered')->andReturn(false);
		WP_Mock::userFunction('wp_register_style')->with('test-style', false, array(), false, 'all')->andReturn(true);
		WP_Mock::userFunction('wp_style_is')->with('test-style', 'enqueued')->andReturn(false);
		WP_Mock::userFunction('wp_enqueue_style')->with('test-style')->andReturn(true);

		// Mock inline script addition.
		WP_Mock::userFunction('wp_add_inline_script')->with('test-script', 'var a = 1;')->andReturn(true);

		// 5. Populate assets on the SUT.
		$sut->set_assets_for_testing(array('general' => array(array('handle' => 'test-script'))));
		$sut->set_styles_for_testing(array('general' => array(array('handle' => 'test-style'))));
		$sut->set_media_tool_configs_for_testing(array(array('args' => array('post' => 1))));
		$sut->set_inline_assets_for_testing(array(array('handle' => 'test-script', 'data' => 'var a = 1;')));

		// 6. Call the method under test.
		$sut->enqueue();

		// If we've reached this point without a Mockery expectation exception, the test is a success.
		// This assertion satisfies PHPUnit's requirement for at least one assertion.
		$this->assertTrue(true);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::enqueue
	 */
	public function test_enqueue_skips_processing_for_absent_asset_types(): void {
		$this->enable_console_logging = true;

		$sut_partial_mock = Mockery::mock(ConcreteEnqueueForCoreTesting::class . '[enqueue_scripts,enqueue_styles,enqueue_media,enqueue_inline_assets]', array($this->config_mock))->makePartial();
		$sut_partial_mock->shouldAllowMockingProtectedMethods();

		// Ensure all asset arrays are empty
		$sut_partial_mock->set_assets_for_testing(array());
		$sut_partial_mock->set_styles_for_testing(array());
		$sut_partial_mock->set_media_tool_configs_for_testing(array());
		$sut_partial_mock->set_inline_assets_for_testing(array()); // enqueue_inline_assets is always called

		// Expect that no WP enqueueing functions are called since all asset arrays are empty.
		WP_Mock::userFunction('wp_enqueue_script')->never();
		WP_Mock::userFunction('wp_enqueue_style')->never();
		WP_Mock::userFunction('wp_add_inline_script')->never();
		WP_Mock::userFunction('wp_enqueue_media')->never();

		$this->expectLog('debug', array('EnqueueAssetBaseAbstract::enqueue - Main enqueue process started.'), 1);
		// Logging for empty assets is now handled within the respective trait methods.
		// The enqueue method in the base class now always calls these handlers.
		$sut_partial_mock->shouldReceive('enqueue_assets')->once()->ordered()->andReturnSelf();
		$sut_partial_mock->shouldReceive('enqueue_styles')->once()->ordered()->andReturnSelf();
		$sut_partial_mock->shouldReceive('enqueue_media')->once()->ordered()->andReturnSelf();
		// enqueue_inline_assets is always called, it handles its own empty state logging.
		$sut_partial_mock->shouldReceive('enqueue_inline_assets')->once()->ordered()->andReturnSelf();

		$this->expectLog('debug', array('EnqueueAssetBaseAbstract::enqueue - Main enqueue process finished.'), 1);

		$sut_partial_mock->enqueue();

		// Add a dummy assertion to prevent the test from being marked as risky.
		// The actual assertions are the Mockery and WP_Mock expectations.
		$this->assertTrue(true, 'Test ran to completion and expectations were met.');
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_executes_simple_callbacks(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'head_test_output_1';
		    }, 'condition' => null),
		    array('callback' => function() {
		    	echo 'head_test_output_2';
		    }, 'condition' => null),
		);
		$this->sut->set_head_callbacks_for_testing($callbacks);

		$this->expectLog('debug', array('render_head', 'Executing head callback 0.'), 1);
		$this->expectLog('debug', array('render_head', 'Executing head callback 1.'), 1);

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();

		$this->assertEquals('head_test_output_1head_test_output_2', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_executes_conditional_callbacks_when_condition_true(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_head_true';
		    }, 'condition' => function() {
		    	return true;
		    })
		);
		$this->sut->set_head_callbacks_for_testing($callbacks);
		$this->logger_mock->shouldReceive('debug')->with('EnqueueAssetBaseAbstract::render_head - Executing head callback 0.')->once();

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();
		$this->assertEquals('conditional_head_true', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_skips_conditional_callbacks_when_condition_false(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_head_false';
		    }, 'condition' => function() {
		    	return false;
		    })
		);
		$this->sut->set_head_callbacks_for_testing($callbacks);
		$this->expectLog('debug', array('render_head', 'Skipping head callback 0 due to false condition.'), 1);

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_head
	 */
	public function test_render_head_handles_no_callbacks_gracefully(): void {
		$this->sut->set_head_callbacks_for_testing(array());
		$this->expectLog('debug', array('render_head', 'No head callbacks to execute.'), 1);

		ob_start();
		$this->sut->render_head();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_executes_simple_callbacks(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'footer_test_output_1';
		    }, 'condition' => null),
		    array('callback' => function() {
		    	echo 'footer_test_output_2';
		    }, 'condition' => null),
		);
		$this->sut->set_footer_callbacks_for_testing($callbacks);

		$this->expectLog('debug', array('render_footer', 'Executing footer callback 0.'), 1);
		$this->expectLog('debug', array('render_footer', 'Executing footer callback 1.'), 1);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();

		$this->assertEquals('footer_test_output_1footer_test_output_2', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_executes_conditional_callbacks_when_condition_true(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_footer_true';
		    }, 'condition' => function() {
		    	return true;
		    })
		);
		$this->sut->set_footer_callbacks_for_testing($callbacks);
		$this->expectLog('debug', array('render_footer', 'Executing footer callback 0.'), 1);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();
		$this->assertEquals('conditional_footer_true', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_skips_conditional_callbacks_when_condition_false(): void {
		$callbacks = array(
		    array('callback' => function() {
		    	echo 'conditional_footer_false';
		    }, 'condition' => function() {
		    	return false;
		    })
		);
		$this->sut->set_footer_callbacks_for_testing($callbacks);
		$this->expectLog('debug', array('render_footer', 'Skipping footer callback 0 due to false condition.'), 1);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}

	/**
	 * @test
	 * @covers \Ran\PluginLib\EnqueueAccessory\EnqueueAssetBaseAbstract::render_footer
	 */
	public function test_render_footer_handles_no_callbacks_gracefully(): void {
		$this->sut->set_footer_callbacks_for_testing(array());
		$this->expectLog('debug', array('render_footer', 'No footer callbacks to execute.'), 1);

		ob_start();
		$this->sut->render_footer();
		$output = ob_get_clean();
		$this->assertEquals('', $output);
	}
}
