# Feature Proposal: WordPress Interactivity API Integration

**Status**: Proposed
**Date**: 2025-01-08
**Deciders**: Development Team
**Technical Story**: Extend BlockRegistrar to support WordPress Interactivity API (WP 6.5+)

## Context

WordPress 6.5 introduced the Interactivity API, providing a standardized way to add client-side interactivity to blocks through reactive state management and directive-based DOM manipulation. This API is used in core WordPress blocks (Search, Query, Navigation, File) and represents the future direction for interactive block development.

### WordPress Interactivity API Overview

- **Core Functions**: `wp_interactivity_data_wp_context()`, `wp_interactivity_config()`
- **Client-Side Store**: Centralized state management with `@wordpress/interactivity`
- **Directive System**: `data-wp-*` attributes for DOM behavior (click, bind, text, etc.)
- **Context-Based**: Data passed via `data-wp-context` attributes to specific DOM elements
- **Reactive Updates**: Automatic DOM updates when state changes
- **Block Communication**: Shared state and actions between different blocks

### Key Concepts

1. **Store Pattern**: Centralized state management similar to Redux/Vuex
2. **Context Data**: Server-to-client data passing via `data-wp-context` attributes
3. **Directives**: DOM behavior definitions using `data-wp-*` attributes
4. **Reactive Binding**: Automatic UI updates when state changes
5. **Namespace Isolation**: Store namespaces prevent conflicts between blocks

### Use Cases

- **Interactive UI Components**: Toggles, accordions, tabs, modals
- **Real-time Updates**: Live search, filtering, sorting
- **Cross-Block Communication**: Shopping cart + product blocks, search + results
- **Progressive Enhancement**: Enhanced functionality without breaking non-JS experiences
- **State Persistence**: Maintain UI state across user interactions

## How Server-Side PHP Achieves Client-Side Interactivity

The WordPress Interactivity API achieves client-side functionality through a clever server-side setup that generates the necessary HTML attributes and JavaScript configuration. Understanding this flow is crucial for implementing the BlockRegistrar integration.

### Key PHP Methods

#### 1. `wp_interactivity_data_wp_context()`

**Purpose**: Generates `data-wp-context` HTML attributes with JSON data

```php
// PHP Server-Side
$context_data = wp_interactivity_data_wp_context([
    'isOpen' => false,
    'count' => 5,
    'apiUrl' => rest_url('my-plugin/v1/')
]);

// Outputs: data-wp-context='{"isOpen":false,"count":5,"apiUrl":"https://example.com/wp-json/my-plugin/v1/"}'
```

#### 2. `wp_interactivity_config()`

**Purpose**: Registers store configuration and initial state

```php
// PHP Server-Side
wp_interactivity_config('my-plugin/block', [
    'namespace' => 'my-plugin/block',
    'state' => [
        'isLoading' => false,
        'items' => []
    ]
]);
```

#### 3. `wp_enqueue_script_module()`

**Purpose**: Enqueues the JavaScript module that contains the interactive logic

```php
// PHP Server-Side
wp_enqueue_script_module('my-block-interactivity', 'path/to/interactivity.js', [
    '@wordpress/interactivity'
]);
```

### Complete Server-to-Client Flow

#### Step 1: Server-Side HTML Generation

```php
// In your block's render.php or render callback
function render_interactive_block($attributes, $content, $block) {
    // Generate context data
    $context_attr = wp_interactivity_data_wp_context([
        'isOpen' => $attributes['defaultOpen'] ?? false,
        'count' => $attributes['initialCount'] ?? 0
    ]);

    // Output HTML with directives and context
    return "
        <div {$context_attr}>
            <button data-wp-on--click='actions.toggle'>
                Toggle Content
            </button>
            <div data-wp-bind--hidden='!context.isOpen'>
                <p data-wp-text='context.count'></p>
                <button data-wp-on--click='actions.increment'>+</button>
            </div>
        </div>
    ";
}
```

#### Step 2: JavaScript Module Registration

```php
// PHP registers the JavaScript module
wp_interactivity_config('my-plugin/block', [
    'state' => [
        'debugMode' => WP_DEBUG
    ]
]);

wp_enqueue_script_module('my-block-interactivity', 'assets/block-interactivity.js');
```

#### Step 3: Client-Side JavaScript (Automatically Loaded)

```javascript
// assets/block-interactivity.js
import { store, getContext } from "@wordpress/interactivity";

store("my-plugin/block", {
  actions: {
    toggle: () => {
      const context = getContext();
      context.isOpen = !context.isOpen;
    },
    increment: () => {
      const context = getContext();
      context.count += 1;
    },
  },
});
```

### The Magic: Server-to-Client Data Flow

#### HTML Output (Generated by PHP)

```html
<div data-wp-context='{"isOpen":false,"count":5}'>
  <button data-wp-on--click="actions.toggle">Toggle Content</button>
  <div data-wp-bind--hidden="!context.isOpen">
    <p data-wp-text="context.count">5</p>
    <button data-wp-on--click="actions.increment">+</button>
  </div>
</div>
```

#### What Happens on the Client

1. **WordPress Interactivity API** scans for `data-wp-*` attributes
2. **Context data** from `data-wp-context` becomes available to JavaScript
3. **Directives** (`data-wp-on--click`, `data-wp-bind--hidden`, etc.) are processed
4. **Event listeners** are automatically attached
5. **Reactive updates** happen when context data changes

### PHP Methods Summary

| **Method**                           | **Purpose**                     | **Output**                          |
| ------------------------------------ | ------------------------------- | ----------------------------------- |
| `wp_interactivity_data_wp_context()` | Generate context HTML attribute | `data-wp-context='{"key":"value"}'` |
| `wp_interactivity_config()`          | Register store configuration    | JavaScript store setup              |
| `wp_enqueue_script_module()`         | Load interactive JavaScript     | `<script type="module">` tag        |
| Block render callback                | Generate HTML with directives   | HTML with `data-wp-*` attributes    |

### Key Insight

The **server-side PHP** doesn't actually handle the interactivity - it just:

1. **Prepares the data** (via `wp_interactivity_data_wp_context()`)
2. **Sets up the configuration** (via `wp_interactivity_config()`)
3. **Generates HTML with directives** (via render callbacks)
4. **Loads the JavaScript** (via `wp_enqueue_script_module()`)

The **client-side JavaScript** (`@wordpress/interactivity`) then:

1. **Reads the context data** from HTML attributes
2. **Processes the directives** to create reactive behavior
3. **Updates the DOM** automatically when data changes

This approach allows you to define interactive behavior declaratively in PHP while achieving reactive client-side functionality!

## Problem Statement

Our current `BlockRegistrar` class provides sophisticated block and asset registration but lacks support for the Interactivity API. This creates gaps in:

- **Interactive Block Development**: No unified way to register interactive blocks with context data
- **State Management Integration**: Cannot define store configuration alongside block registration
- **Asset Coordination**: No automatic handling of interactivity script modules
- **Developer Experience**: Fragmented APIs for interactive vs static blocks

### Current System Strengths

Our existing `BlockRegistrar` provides:

- Unified block and asset registration
- Conditional registration with hook/priority control
- Comprehensive logging and error handling
- Integration with scripts, styles, and asset management
- Support for WordPress block properties and custom extensions

### Current Data Passing Capabilities vs Interactivity API

| **Method**                     | **Current BlockRegistrar Support** | **Data Type**        | **Scope**        | **Reactivity**  | **Use Case**                 |
| ------------------------------ | ---------------------------------- | -------------------- | ---------------- | --------------- | ---------------------------- |
| **`wp_localize_script()`**     | âœ… Via `localize` property         | Global variables     | Page-wide        | âŒ Static       | Initial config, translations |
| **`script_module_data_{$id}`** | âœ… Via `module_data` property      | Scoped to module     | Module-specific  | âŒ Static       | ES6 module configuration     |
| **Block Bindings API**         | ðŸš§ Planned (separate TFS)          | Server-side dynamic  | Block attributes | âŒ Static       | Dynamic content binding      |
| **Interactivity API**          | âŒ **Missing**                     | Client-side reactive | DOM context      | âœ… **Reactive** | Interactive UI state         |

**Current BlockRegistrar Example:**

```php
$block_registrar->add([
    'block_name' => 'my-plugin/block',
    'assets' => [
        'scripts' => [
            'handle' => 'my-block-script',
            'localize' => [
                'object_name' => 'myBlockData',
                'data' => ['apiUrl' => rest_url(), 'nonce' => wp_create_nonce()]
            ]
        ],
        'script_modules' => [
            'handle' => 'my-block-module',
            'module_data' => ['config' => get_option('my_settings')]
        ]
    ]
]);
```

#### Missing: Interactivity API Integration

```php
// Current approach - fragmented registration
register_block_type('my-plugin/interactive-block', [
    'render_callback' => 'render_block',
    'view_script_module' => 'my-block-interactivity'
]);

// Separate interactivity setup
wp_interactivity_config('my-plugin/block', [
    'namespace' => 'my-plugin/block'
]);

// Manual context data in render callback
function render_block($attributes, $content, $block) {
    $context_data = wp_interactivity_data_wp_context([
        'isOpen' => false,
        'count' => $attributes['initialCount'] ?? 0
    ]);

    return "<div {$context_data}>{$content}</div>";
}
```

### Key Differences

**Interactivity API provides:**

- **Reactive State Management**: UI automatically updates when data changes
- **DOM-Scoped Data**: Context data attached to specific DOM elements
- **Client-Side Interactivity**: Real-time user interaction handling
- **Cross-Block Communication**: Shared state between different blocks
- **Progressive Enhancement**: Graceful degradation without JavaScript

**Our current system provides:**

- **Static Data Passing**: One-time server-to-client data transfer
- **Asset Management**: Sophisticated conditional loading and optimization
- **Performance Features**: Request-scoped caching, bundling, deferring
- **Unified Registration**: Single API for scripts, styles, and modules

## How Interactivity API Complements Block Bindings API

The Interactivity API and Block Bindings API serve complementary but distinct purposes in the WordPress block ecosystem. Understanding their relationship is crucial for implementing a complete dynamic block solution.

### Complementary Roles

#### Block Bindings API: Server-Side Dynamic Content

- **Purpose**: Connects block attributes to server-side data sources
- **When**: During server-side rendering (PHP)
- **What**: Populates block content with dynamic data
- **Examples**: Post meta, user data, API responses, database queries

#### Interactivity API: Client-Side Reactive Behavior

- **Purpose**: Handles user interactions and reactive UI updates
- **When**: Client-side after page load (JavaScript)
- **What**: Manages interactive state and user interactions
- **Examples**: Toggles, form interactions, real-time updates

### Data Flow Combination

```php
// Block Bindings: Server-side data population
register_block_bindings_source('my-plugin/user-profile', [
    'label' => 'User Profile Data',
    'get_value_callback' => function($source_args, $block_instance) {
        return [
            'username' => wp_get_current_user()->display_name,
            'avatar_url' => get_avatar_url(get_current_user_id()),
            'post_count' => count_user_posts(get_current_user_id())
        ];
    }
]);

// Interactivity API: Client-side interactive behavior
function render_user_profile_block($attributes, $content, $block) {
    // Block Bindings provides the data
    $user_data = get_block_bindings_data($block);

    // Interactivity API handles the interactive state
    $context_data = wp_interactivity_data_wp_context([
        'isExpanded' => false,
        'showDetails' => $attributes['showDetailsByDefault'] ?? false,
        // Server data becomes part of interactive context
        'userData' => $user_data
    ]);

    return "<div {$context_data}>
        <h3 data-wp-text='context.userData.username'></h3>
        <button data-wp-on--click='actions.toggleDetails'>
            Show Details
        </button>
        <div data-wp-bind--hidden='!context.showDetails'>
            <img data-wp-bind--src='context.userData.avatar_url' />
            <p data-wp-text='context.userData.post_count'></p>
        </div>
    </div>";
}
```

### Complementary Scopes

| **Aspect**           | **Block Bindings API**                | **Interactivity API**                        |
| -------------------- | ------------------------------------- | -------------------------------------------- |
| **Data Source**      | Server-side (PHP functions, DB, APIs) | Client-side (user interactions, local state) |
| **Update Timing**    | Page load / server render             | Real-time user interactions                  |
| **Data Persistence** | Persistent (database, external APIs)  | Ephemeral (session-based, UI state)          |
| **Use Cases**        | Dynamic content, personalization      | Interactive UI, user feedback                |

### Practical Combined Examples

#### Shopping Cart Block

```php
// Block Bindings: Server-side cart data
register_block_bindings_source('my-shop/cart-data', [
    'get_value_callback' => function() {
        return [
            'items' => WC()->cart->get_cart(),
            'total' => WC()->cart->get_cart_total(),
            'item_count' => WC()->cart->get_cart_contents_count()
        ];
    }
]);

// Interactivity API: Client-side cart interactions
$context_data = wp_interactivity_data_wp_context([
    'isOpen' => false,
    'isUpdating' => false,
    // Server data from Block Bindings
    'cartData' => $block_bindings_data
]);
```

#### Live Search Block

```php
// Block Bindings: Initial search results
register_block_bindings_source('my-plugin/search-results', [
    'get_value_callback' => function($source_args) {
        return get_posts([
            'post_type' => $source_args['post_type'] ?? 'post',
            'posts_per_page' => 5
        ]);
    }
]);

// Interactivity API: Real-time search interactions
$context_data = wp_interactivity_data_wp_context([
    'searchTerm' => '',
    'isSearching' => false,
    // Initial results from Block Bindings
    'initialResults' => $block_bindings_data,
    'currentResults' => $block_bindings_data
]);
```

### Key Complementary Benefits

#### 1. Complete Data Lifecycle

- **Block Bindings**: Provides initial server-side data
- **Interactivity API**: Manages client-side state changes
- **Together**: Full data lifecycle from server to interactive client

#### 2. Performance Optimization

- **Block Bindings**: Server-side caching, database optimization
- **Interactivity API**: Client-side reactive updates without full page reloads
- **Together**: Optimal performance for both initial load and interactions

#### 3. Progressive Enhancement

- **Block Bindings**: Works without JavaScript (server-rendered content)
- **Interactivity API**: Enhances with JavaScript when available
- **Together**: Graceful degradation and progressive enhancement

#### 4. Developer Experience

- **Block Bindings**: Familiar PHP patterns for data access
- **Interactivity API**: Modern JavaScript reactive patterns
- **Together**: Best of both worlds for full-stack developers

### BlockRegistrar Integration Vision

Both APIs would integrate into the `BlockRegistrar` system:

```php
$block_registrar->add([
    'block_name' => 'my-plugin/dynamic-interactive-block',

    // Block Bindings integration (planned in separate TFS)
    'bindings' => [
        'source' => 'my-plugin/user-data',
        'callback' => 'get_user_profile_data'
    ],

    // Interactivity API integration (this TFS)
    'interactivity' => [
        'namespace' => 'my-plugin/user-block',
        'context' => ['isExpanded' => false],
        'store_config' => ['debugMode' => WP_DEBUG]
    ],

    // Asset management (existing)
    'assets' => [
        'script_modules' => [
            'handle' => 'user-block-interactivity',
            'deps' => ['@wordpress/interactivity']
        ]
    ]
]);
```

**Key Insight**: Block Bindings API provides the **data foundation**, while Interactivity API provides the **interactive behavior**. Together, they enable blocks that are both dynamically populated with server data AND interactively responsive to user actions.

## Decision

Extend `BlockRegistrar` with **integrated Interactivity API support** while maintaining backward compatibility and leveraging existing asset management infrastructure.

### Key Design Principles

1. **Unified Registration**: Interactive blocks registered alongside static blocks
2. **Declarative Configuration**: Context data and store config defined in block definition
3. **Asset Integration**: Automatic handling of interactivity script modules
4. **Namespace Management**: Automatic namespace generation and conflict prevention
5. **Progressive Enhancement**: Graceful degradation when JavaScript is disabled

### Implementation Architecture

#### 1. Extended Block Definition Format

```php
$block_registrar->add([
    'block_name' => 'my-plugin/interactive-block',
    'render_callback' => [$this, 'render_block'],

    // NEW: Interactivity API integration
    'interactivity' => [
        'store_namespace' => 'my-plugin/block',  // Optional, auto-generated if not provided
        'context_data' => [
            'isOpen' => false,
            'count' => 0,
            'apiUrl' => rest_url('my-plugin/v1/'),
            'settings' => function() { return get_option('my_plugin_settings', []); }
        ],
        'store_config' => [
            'state' => [
                'isLoading' => false
            ],
            'actions' => [
                'toggle' => 'actions.toggle',
                'fetchData' => 'actions.fetchData'
            ]
        ],
        'view_script_module' => 'my-block-interactivity',  // Auto-registered
        'condition' => function() { return !is_admin(); }  // Conditional interactivity
    ]
]);
```

#### 2. Automatic Context Data Injection

```php
// BlockRegistrar automatically injects context data
protected function _process_interactivity_context(array $block_definition, array $attributes): string {
    if (!isset($block_definition['interactivity']['context_data'])) {
        return '';
    }

    $context_data = $block_definition['interactivity']['context_data'];

    // Process callable context data
    foreach ($context_data as $key => $value) {
        if (is_callable($value)) {
            $context_data[$key] = $value();
        }
    }

    // Merge with block attributes if needed
    $context_data = array_merge($context_data, $attributes['interactivityData'] ?? []);

    $namespace = $block_definition['interactivity']['store_namespace'] ??
                 $this->generate_store_namespace($block_definition['block_name']);

    return wp_interactivity_data_wp_context($context_data, $namespace);
}
```

#### 3. Store Configuration Management

```php
// Automatic store configuration registration
protected function _register_interactivity_store(array $block_definition): void {
    $store_config = $block_definition['interactivity']['store_config'] ?? [];
    $namespace = $block_definition['interactivity']['store_namespace'] ??
                 $this->generate_store_namespace($block_definition['block_name']);

    if (!empty($store_config)) {
        wp_interactivity_config($namespace, $store_config);
    }

    // Auto-register view script module if specified
    if (isset($block_definition['interactivity']['view_script_module'])) {
        $this->register_interactivity_script_module($block_definition);
    }
}
```

#### 4. Enhanced Render Callback Integration

```php
// Modified render callback to inject context data
public function _render_block_with_interactivity($attributes, $content, $block) {
    $block_definition = $this->get_block_definition($block->name);

    if (isset($block_definition['interactivity'])) {
        $context_attr = $this->process_interactivity_context($block_definition, $attributes);

        // Inject context data into block wrapper
        if ($context_attr && !empty($content)) {
            $content = $this->inject_context_attribute($content, $context_attr);
        }
    }

    return $content;
}
```

## Implementation Examples

### Basic Interactive Block

```php
$block_registrar->add([
    'block_name' => 'my-plugin/toggle',
    'render_callback' => [$this, 'render_toggle'],
    'interactivity' => [
        'context_data' => [
            'isOpen' => false,
            'label' => __('Toggle Content', 'my-plugin')
        ],
        'view_script_module' => 'my-toggle-interactivity'
    ]
]);
```

### Advanced Interactive Block with Dynamic Data

```php
$block_registrar->add([
    'block_name' => 'my-plugin/live-search',
    'render_callback' => [$this, 'render_search'],
    'interactivity' => [
        'store_namespace' => 'my-plugin/search',
        'context_data' => [
            'query' => '',
            'results' => [],
            'isLoading' => false,
            'apiUrl' => function() { return rest_url('my-plugin/v1/search'); },
            'nonce' => function() { return wp_create_nonce('search_nonce'); }
        ],
        'store_config' => [
            'state' => [
                'debounceTimer' => null
            ],
            'actions' => [
                'search' => 'actions.performSearch',
                'clearResults' => 'actions.clearResults'
            ]
        ],
        'view_script_module' => 'my-search-interactivity',
        'condition' => function() { return !is_admin() && current_user_can('read'); }
    ],
    'assets' => [
        'styles' => ['my-search-styles.css']
    ]
]);
```

### Cross-Block Communication Example

```php
// Shopping cart block
$block_registrar->add([
    'block_name' => 'my-plugin/cart',
    'interactivity' => [
        'store_namespace' => 'my-plugin/shop',  // Shared namespace
        'context_data' => [
            'items' => function() { return WC()->cart->get_cart(); },
            'total' => function() { return WC()->cart->get_total(); }
        ]
    ]
]);

// Add to cart button block
$block_registrar->add([
    'block_name' => 'my-plugin/add-to-cart',
    'interactivity' => [
        'store_namespace' => 'my-plugin/shop',  // Same namespace for communication
        'context_data' => [
            'productId' => 0,
            'quantity' => 1
        ]
    ]
]);
```

## Benefits

1. **Unified Development Experience**: Single API for all block types (static and interactive)
2. **Automatic Asset Management**: Seamless integration with existing asset handling
3. **Enhanced Developer Productivity**: Declarative configuration reduces boilerplate
4. **Consistent Patterns**: Same conditional loading, logging, and error handling
5. **Progressive Enhancement**: Graceful degradation built-in
6. **Cross-Block Communication**: Simplified state sharing between blocks
7. **Performance Optimization**: Leverage existing caching and optimization infrastructure

## Technical Considerations

### WordPress Version Requirements

- **Interactivity API**: WordPress 6.5+ required
- **Script Modules**: WordPress 6.5+ required for view script modules
- **Enhanced Features**: WordPress 6.7+ recommended for latest improvements

### Backward Compatibility

- All existing block registrations continue to work unchanged
- Interactivity features are opt-in through the `interactivity` property
- Non-interactive blocks are unaffected by the new functionality

### Performance Impact

- Context data processing only occurs for blocks with interactivity configuration
- Conditional interactivity loading prevents unnecessary overhead
- Leverage existing asset optimization and caching infrastructure
- Store configuration registered only once per namespace

### Security Considerations

- Context data sanitization and validation
- Nonce integration for AJAX operations
- Capability checks for sensitive data
- XSS prevention in context data output

## Implementation Plan

### Phase 1: Core Integration

- [ ] **Basic Context Data Support**: Implement `context_data` property processing
- [ ] **Store Namespace Management**: Automatic namespace generation and conflict prevention
- [ ] **Render Callback Enhancement**: Context data injection into block output
- [ ] **Asset Integration**: Automatic view script module registration

### Phase 2: Advanced Features

- [ ] **Store Configuration**: Full store config registration and management
- [ ] **Conditional Interactivity**: Apply existing conditional logic to interactive features
- [ ] **Cross-Block Communication**: Shared namespace and state management
- [ ] **Performance Optimization**: Caching and optimization for context data

### Phase 3: Developer Experience

- [ ] **Enhanced Logging**: Debug information for interactivity registration
- [ ] **Validation and Sanitization**: Comprehensive data validation
- [ ] **Documentation and Examples**: Complete usage documentation
- [ ] **Testing Infrastructure**: Comprehensive test coverage

## Risks and Mitigations

### Risk: WordPress API Changes

**Mitigation**: Monitor WordPress core development and maintain compatibility layers

### Risk: Performance Impact

**Mitigation**: Implement conditional loading and leverage existing optimization infrastructure

### Risk: Complexity Increase

**Mitigation**: Start with minimal viable implementation and expand gradually

### Risk: Developer Learning Curve

**Mitigation**: Comprehensive documentation, examples, and migration guides

## Alternatives Considered

### Separate Interactivity Handler

**Rejected**: Would create fragmentation and duplicate existing infrastructure

### WordPress Core Integration Only

**Rejected**: Misses opportunities for enhanced developer experience and asset integration

### Manual Implementation

**Rejected**: Increases complexity and reduces consistency across projects

## Conclusion

Integrating WordPress Interactivity API support into `BlockRegistrar` provides a comprehensive solution for modern interactive block development. This enhancement maintains architectural consistency while enabling developers to create rich, interactive user experiences through a unified, declarative API.

The implementation leverages existing asset management infrastructure, provides progressive enhancement capabilities, and positions the system at the forefront of WordPress block development. By supporting both static and interactive blocks through the same registration interface, developers can focus on creating great user experiences rather than managing complex integration patterns.

This feature represents a natural evolution of the `BlockRegistrar` system, completing the vision of unified block and asset management for the modern WordPress development ecosystem.
