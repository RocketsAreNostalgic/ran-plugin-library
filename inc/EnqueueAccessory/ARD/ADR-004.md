# ADR-004: Hybrid Asset Management Architecture

**Date:** 2025-07-11
**Status:** Accepted

## Context

The asset management system requires a design that is both flexible and robust. Two primary challenges were identified:

1. An inheritance-centric model, where consumers extend a large base class, leads to tight coupling and poor testability.
2. A direct composition model, where a class uses multiple asset-specific traits, caused fatal errors from PHP's trait method name collisions, as discribed in ADR-003.

The chosen hybrid architecture solves both problems. By encapsulating each asset-specific trait within a dedicated Handler class that inherits a Dispatcher Engine, we create components that are both independently testable (solving #1) and free from method collision risks (solving #2). This provides a clean, composable interface for the final consumer classes.

This ADR describes the final, hybrid architecture that combines the strengths of both **Composition** and **Inheritance** at different layers to create a system that is flexible, testable, and internally robust.

## Decision

The architecture is composed of two primary patterns working in concert:

1. **High-Level: Composition of Handlers:** Top-level consumer classes (e.g., `EnqueueAdmin`) are composed of dedicated, single-responsibility `Handler` classes (`ScriptsHandler`, `StylesHandler`, `MediaHandler`). The consumer acts as a clean facade, delegating all asset-specific work to the appropriate handler. This makes the system highly flexible and easy to test.

2. **Low-Level: Inheritance-Based Dispatcher:** Each handler (eg `ScriptsHandler`) extends `AssetHandlerBase`, which in turn extends `AssetEnqueueBaseAbstract`. This inheritance chain provides each handler with an internal **dispatcher engine**. This engine's primary purpose is to solve the PHP trait method-name-collision problem by routing generic calls to uniquely named methods within the asset-specific traits.

### Overall Architectural Diagram

This diagram illustrates how both patterns work together.

```ascii
+--------------------------------------------------+      HIGH-LEVEL: COMPOSITION
| External Client                                  |      (Decoupling & Testability)
|                                                  |
| $enqueue_admin = new EnqueueAdmin($config);      |
| $enqueue_admin->add_scripts([...]);              |
|                                                  |
+--------------------------------------------------+
                     |
                     V
+---------------------------------------------------------------+
|                        EnqueueAdmin                           |
|---------------------------------------------------------------|
| - $scripts_handler: ScriptsHandler                            |
|                                                               |
| add_scripts(...) {                                            |
|   $this->scripts_handler->add_scripts(...); // DELEGATES      |
| }                                                             |
+---------------------------------------------------------------+
                          |
                          V
+-------------------------------------------------------------+  LOW-LEVEL: INHERITANCE
|           ScriptsHandler/StylesHandler                      |  (High-Level: Composition)
|-------------------------------------------------------------|
| extends AssetEnqueueBaseAbstract                            |
| use ScriptsEnqueueTrait                                     |
|                                                             |
| // Inherits the dispatcher from its parent, which calls     |
| // the trait's uniquely-named method.                       |
+-------------------------------------------------------------+
                          |
                          | extends
                          V
+-------------------------------------------------------------+
|                  AssetEnqueueBaseAbstract                   |
|-------------------------------------------------------------|
| // The dispatcher logic lives here!                         |
| // match ($asset_type) { ... }                              |
|                                                             |
| // It pulls in all the trait methods:                       |
| + use AssetEnqueueBaseTrait; //<-- Has generic helpers      |
| + use ScriptsEnqueueTrait;  //<-- Has SCRIPT-specific logic |
| + use StylesEnqueueTrait;   //<-- Has STYLE-specific logic  |
+-------------------------------------------------------------+

```

## Consequences

This hybrid approach yields the following trade-offs:

- **Pros:**

  - **Testability:** The high-level composition allows each handler to be tested in complete isolation.
  - **Separation of Concerns:** `EnqueueAdmin` is a clean facade. `ScriptsHandler` only knows about scripts. `AssetEnqueueBaseAbstract` only knows about dispatching.
  - **Trait Management:** The low-level dispatcher solves the trait method collision problem cleanly without requiring awkward method renaming in the traits themselves.
  - **Flexibility:** Consumers can be composed of only the handlers they need.

- **Cons:**
  - **Architectural Complexity:** The system uses two nested patterns, which requires a deeper understanding of the architecture to maintain or extend.
  - **Increased Class Count:** The pattern is inherently more verbose than a single monolithic class, introducing several handler and base classes.
