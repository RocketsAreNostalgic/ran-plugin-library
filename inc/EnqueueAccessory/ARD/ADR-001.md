# ADR-001: Preemptive Asset State Inspection for Hook Registration

**Date:** 2025-06-25
**Status:** Accepted

## Context

The WordPress plugin asset enqueueing lifecycle requires that all actions (like `add_action('wp_head', ...)` or `add_action('custom_hook', ...)` ) be registered during the `wp_enqueue_scripts` hook. However, the full processing of assets—which determines if they have head/footer callbacks or are deferred to a custom hook—happens within the same `wp_enqueue_scripts` hook.

This creates a critical timing issue: the system doesn't know it needs to register a `wp_head` action until *after* the window to register that action has already passed. The `EnqueuePublic::load()` method, which is responsible for registering these hooks, runs before the asset processing is complete.

## Decision

We will implement a "preemptive check" or "look-ahead" mechanism in the methods responsible for reporting asset requirements. Specifically, `get_head_callbacks()`, `get_footer_callbacks()`, and `get_deferred_hooks()` will now inspect the raw, unprocessed `$assets` array in addition to the processed asset arrays.

They will look for asset definitions that contain properties (`'data'`, `'hook'`) indicating that they *will require* a future action (`wp_head`, `wp_footer`, or a custom hook).

This allows the `EnqueuePublic::load()` method to get a complete and accurate picture of all necessary hooks upfront and register them at the correct time within the WordPress lifecycle.

## Alternatives Considered

### Process Assets During `load()`

We considered eliminating the look-ahead mechanism by simply processing all assets inside the `EnqueuePublic::load()` method. This would populate the `head_callbacks`, `footer_callbacks`, and `deferred_assets` arrays directly, making the look-ahead logic redundant.

**Why this was rejected:** The `load()` method is designed to run early in the WordPress lifecycle (e.g., on `init`) to schedule actions. The official and only correct time to *call* `wp_enqueue_script()` and `wp_enqueue_style()` is during the `wp_enqueue_scripts` hook, which fires much later. Processing assets inside `load()` would force us to enqueue them too early, which would break all conditional loading (e.g., `is_page()`, `is_singular()`). This would be a critical loss of functionality and a major performance anti-pattern. The current approach is a deliberate trade-off to preserve this essential feature.

## Consequences

### Pros

* **Functional Correctness:** This approach ensures the enqueueing system is robust and reliable within the strict constraints of the WordPress action lifecycle.
* **Preserves Conditional Loading:** It allows the library to continue using `wp_enqueue_scripts` as its main hook, preserving the ability to use powerful conditional tags (e.g., `is_page()`) to load assets efficiently.
* **Encapsulated Complexity:** The timing complexity is handled internally. The end-user of the library has a simple, predictable API (`add_scripts()`, `add_styles()`) that works as expected.

### Cons

* **Logic Duplication (Violates DRY):** The logic for identifying an asset with a head callback or a deferred hook now exists in two places: the preemptive check and the final asset processing logic (e.g., in `_process_single_script()`).
* **Tighter Coupling:** The "look-ahead" logic is now tightly coupled to the internal data structure of the raw, unprocessed asset array. Changes to this structure would require updates in multiple places.
* **Architectural Trade-off:** This solution sacrifices a degree of architectural purity (like strict adherence to DRY) for pragmatic, robust functionality in the target environment. It is a deliberate and accepted trade-off.
