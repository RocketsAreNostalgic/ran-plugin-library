# ADR-002: Two-Stage Asset Registration and Enqueuing

**Date**: 2025-07-03
**Status**: Accepted

## Context

Managing JavaScript and CSS assets in WordPress requires adherence to a specific lifecycle: assets must first be **registered** with a unique handle and then **enqueued** to be included on a page. This library provides a streamlined, object-oriented interface for managing this process. The core architectural challenge is to provide a powerful and flexible API that aligns with WordPress best practices while remaining intuitive for developers.

### Input Validation and Error Handling

To ensure robustness and prevent silent failures, a strict, fail-fast validation strategy has been implemented at the point of asset addition.

1. **Centralized Validation**: All validation logic is consolidated within the `AssetEnqueueBaseTrait::add_assets()` method. This is the single entry point for adding both scripts and styles to the system.

2. **Strict Checks**: When `add_assets()` is called, it iterates through each provided asset definition and performs the following checks:

   - The asset **must** have a `handle` key with a non-empty string value.
   - The asset **must** have a `src` key, and its value must either be a non-empty string or the boolean `false`. An empty string or `null` is considered invalid.

3. **Fail-Fast with Exceptions**: If any asset definition fails these validation checks, the method immediately throws an `InvalidArgumentException`. The exception message clearly indicates which asset is invalid and why (e.g., "Invalid script definition at index 0. Asset must have a 'handle'.").

## Decision

We have implemented a decoupled, multi-stage process for asset management that mirrors the WordPress core lifecycle but provides more explicit control and safety. This state machine ensures that assets are registered and enqueued at the correct time, respecting WordPress's loading sequence.

The process is managed by the following primary methods, which must be called in a specific order:

1. **`add_assets()`** (e.g., `add_scripts()`): This is the first step. You add all asset definitions (both immediate and deferred) to an internal queue. This method only collects definitions and performs initial validation; it does no WordPress-related processing.

2. **`stage_assets()`** (e.g., `stage_scripts()`): This is the critical gatekeeper stage. It iterates through the assets added in the previous step.

   - **For deferred assets** (those with a `hook` key): Its main responsibility is to set up the WordPress action (`add_action`) that will process the asset when its specific hook fires. It also moves the asset to a separate "deferred" queue, effectively taking it out of the immediate processing pipeline. This ensures deferred assets are handled in the correct context.
   - **For immediate assets** (those without a `hook` key): It leaves them in the main queue, ready for the next stage.

3. **`enqueue_immediate_assets()`** (e.g., `enqueue_immediate_scripts()`): This is the final stage for immediate assets.

   - It iterates through the assets remaining in the main queue (which are, by design, only the immediate assets).
   - It registers and enqueues each one using `wp_register_script()`/`wp_enqueue_script()` or `wp_register_style()`/`wp_enqueue_style()`.
   - After an asset is successfully enqueued, it is removed from the queue.
   - **Important**: This method only processes the immediate asset queue. Because `stage_assets()` moves all deferred assets to a separate queue, this method should never encounter them. This strict separation prevents race conditions. If a deferred asset is found, it signifies a critical logic flaw, and the system will throw a `LogicException`.

4. **`_enqueue_deferred_assets()`** (e.g., `_enqueue_deferred_scripts()`): This method is the callback triggered by the WordPress hook set up in the `stage_assets()` stage. It is not called directly. When triggered by a hook (e.g., `wp_footer`), it performs the following critical operations:

   - It immediately copies the assets for that specific hook to a local variable and then **removes them from the main deferred queue**. This "copy and unset" pattern ensures that assets for a given hook are processed exactly once, preventing race conditions or duplicate processing if a hook were to fire multiple times.
   - It then iterates over the local copy, registering and enqueuing each asset.
   - This means the deferred asset queue is actively and safely emptied during the request lifecycle.

This architecture establishes a clear and predictable state flow for each asset, from addition to final output on the page.

### Handling Inline Assets

The system provides two flexible mechanisms for adding inline CSS and JavaScript, catering to different use cases.

**1. The `inline` Property (Simple Use Case)**

For simple cases where a piece of inline code is tightly coupled with a specific asset file, you can add an `inline` key directly to the asset's definition array.

- **How it works:** The inline content is attached to its parent asset during the standard registration/enqueuing process.
- **Requirement:** The parent asset must have a valid `src`.
- **Example:**

  ```php
  $this->add_styles([
      [
          'handle' => 'my-component-style',
          'src'    => 'path/to/style.css',
          'inline' => '.component { color: red; }'
      ]
  ]);
  ```

**2. Dedicated Methods: `add_inline_scripts()` & `add_inline_styles()` (Advanced Use Case)**

For more complex scenarios, such as adding inline code that is decoupled from the parent asset's definition or adding multiple inline blocks to the same parent, you can use the dedicated `add_inline_*` methods.

- **How it works:** These methods add inline asset definitions to a separate, dedicated queue. They are processed later when you call `enqueue_inline_scripts()` or `enqueue_inline_styles()`.
- **Requirement:** The `handle` property must refer to an _already registered_ asset. The inline content is provided via the `data` (for scripts) or `content` (for styles) key.
- **Example:**

  ```php
  // First, add the main asset
  $this->add_styles([['handle' => 'my-component-style', 'src' => 'path/to/style.css']]);

  // Later, from anywhere else...
  $this->add_inline_styles([
      [
          'handle'  => 'my-component-style',
          'content' => '.component .title { font-weight: bold; }',
      ]
  ]);

  // Finally, trigger the enqueueing of the inline assets
  $this->enqueue_inline_styles();
  ```

This approach provides greater flexibility for managing complex or conditionally-loaded inline assets.

**Interaction with Deferred Assets**

How inline assets are handled depends on the method used:

- **Using the `inline` property**: If an asset with an `inline` property is deferred (using the `hook` key), the inline script/style is automatically deferred with it. The inline data is processed at the same time the parent asset is registered and enqueued, ensuring correct timing.

- **Using `add_inline_*` methods**: This method requires that the parent asset be _already registered_. Since a deferred asset's registration is delayed until its hook fires, you must also delay the addition and enqueuing of the inline asset to the same hook (or a later one). Attempting to attach an inline asset to a deferred handle before its hook has fired will fail.

### Recommended Usage Pattern

The intended workflow is to instantiate a pre-built handler class (like `EnqueueAdmin`) and use its methods to add assets. The handler takes care of hooking itself into WordPress and managing the entire registration and enqueueing lifecycle automatically.

**Pseudo-code Example:**

```php
// --- In a central service registration file (e.g., RegisterServices.php) ---

// 1. The system instantiates the appropriate handler.
//    Assuming $plugin_config is an available instance of ConfigInterface.
$admin_asset_handler = new \Ran\PluginLib\EnqueueAccessory\EnqueueAdmin( $plugin_config );

// 2. The handler's load() method is called to hook it into WordPress.
$admin_asset_handler->load();


// --- In a different part of the plugin (e.g., a specific feature's class) ---

// 3. The developer gets access to the handler instance (e.g., via a service locator or DI).
//    They then add assets as needed.

// Example: Adding a script for a custom admin page.
$admin_asset_handler->add_scripts([
    'my-admin-feature' => [
        'src'       => 'path/to/admin-feature.js',
        'deps'      => ['wp-api'],
        'ver'       => '1.0.0',
        'in_footer' => true
    ]
]);

// Example: Adding a style for that same page.
$admin_asset_handler->add_styles([
    'my-admin-styles' => [
        'src' => 'path/to/admin-styles.css'
    ]
]);

// The registration and enqueuing is now handled automatically by the
// methods that EnqueueAdmin::load() hooked into WordPress. The developer's
// only job is to add the assets.

*Note: While the handler exposes public methods like `enqueue_scripts()`, these should not be called in a standard workflow. They are provided as an "escape hatch" for advanced use cases where assets must be enqueued outside of the standard WordPress hooks (e.g., in an AJAX callback).*
```

This pattern provides flexibility, allowing a developer to define a large library of assets once, and then conditionally enqueue them based on the context of a specific page.

## Consequences

This design choice has several significant consequences, both positive and negative.

### Strengths

- **Alignment with WordPress Core**: The two-step process (`register` then `enqueue`) directly maps to the standard, recommended WordPress pattern. This makes the system more predictable for experienced WordPress developers.
- **Enhanced Flexibility**: Developers gain the ability to register a comprehensive library of assets at an early stage (e.g., on `init`) and then conditionally enqueue only the specific assets needed for a particular page view. This is a powerful pattern for complex plugins and themes.
- **Improved Testability**: Decoupling the logic allows for more focused and robust unit testing. We can write tests that verify the registration logic independently from the enqueuing logic.
- **Clear Separation of Concerns**: Each method has a single, well-defined responsibility. `register_assets()` is concerned with making WordPress aware of assets, while `stage_assets()` is concerned with adding them to the page.

### Weaknesses

- **Increased API Surface**: The primary drawback is that developers must now call two methods in the correct sequence to fully render an asset. Forgetting to call `stage_assets()` after `register_assets()` will result in the asset being registered but not appearing on the page.
- **Implicit State Management**: The status of an asset is tracked implicitly by its presence in the internal queue. There is no explicit `is_registered` flag on the asset definition itself, which requires developers to understand the stateful nature of the process.

### Error Handling and Forgiveness

The system is designed to be both robust and forgiving, handling common developer errors gracefully while preventing critical misconfigurations.

- **Forgiving Enqueuing of Unregistered Assets**: If a developer skips the `register_assets()` step for a non-deferred asset and calls `stage_assets()` directly, the system does not fail. Instead, it logs a `warning` to alert the developer of a potential logic error, then proceeds to both register and enqueue the asset. This behavior mirrors the flexibility of WordPress's native `wp_enqueue_script()` function.

- **Strict Handling of Deferred Assets**: In contrast, attempting to enqueue a _deferred_ asset (one defined with a `hook`) without first calling `register_assets()` is a critical misuse of the API. The `register_assets()` method is essential for correctly parsing the hook and setting up the deferred action. If `stage_assets()` finds a deferred asset in the immediate queue, it will throw a `LogicException` to halt execution and force the developer to correct the call order. This prevents assets from being loaded in the wrong context (e.g., an admin script loading on the frontend).
