# ADR-003: The Trait Dispatcher Pattern

**Date:** 2025-07-11
**Status:** Referenced by ADR-004

## Context

Due to the many common patterns in the WordPress APIs for scrips and style, there is an oppertunity to centeralise much of the logic into a common base. However PHP does not allow for multiple inhertance, so after some review we decided on a trait based system where a common base trait (`EnqueueAssetBaseTrait`) would hold shared logic and a then individual traits (e.g. `ScriptsEnqueueTrait`, `StylesEnqueuTrait`) would extend this base, and hold only asset specific logc.

The chalange arises when a class attempts uses multiple PHP traits that have a shared base, as it will lead to a fatal error when two or more traits surface methods with the same name, e.g. the underlying methods in the base trait. For example, a class that contolls the asset loading on a plugin's admin screens would need both `ScriptsEnqueueTrait` and `StylesEnqueueTrait` which logically both need the a shared method like `_process_asset()`. A class using both traits would fail.

We need a robust pattern to allow a class to safely compose functionality from multiple traits without risking these method name collisions.

## Decision

We will implement a **Trait Dispatcher Pattern**. This pattern involves a base class that consumes the traits and acts as a central router. The key components are:

1.  **Uniquely-Named Trait Methods:** The methods in the traits are given unique, specific names (e.g., `_process_single_script_asset()` instead of a generic name).
2.  **A Central Dispatcher Method:** The base class provides a single, generic method (e.g., `_process_single_asset()`).
3.  **A Routing Argument:** The dispatcher method accepts an argument (e.g., an `AssetType` enum) that tells it which type of logic to execute.
4.  **Internal Routing:** The dispatcher uses a `match` statement on the routing argument to forward the call to the correct, uniquely-named method from the appropriate trait.

### Architectural Diagram

This diagram shows the internal logic of the dispatcher pattern.

```ascii
// 1. An external call is made to the generic dispatcher method.
Call -> [DispatcherClass::_process_single_asset(AssetType::Script, ...)]
                                |
                                |
// 2. The dispatcher uses a `match` statement on the AssetType.
                                V
                      +--------------------+
                      | match($asset_type) |
                      +--------------------+
                      /                    \
                     /                      \
      (AssetType::Script)            (AssetType::Style)
            |                              |
            |
// 3. The call is dispatched to the uniquely-named method from the correct trait.
            V                              V
+---------------------------+    +--------------------------+
|  ScriptsEnqueueTrait::    |    |   StylesEnqueueTrait::   |
| _process_single_script..()|    | _process_single_style..()|
+---------------------------+    +--------------------------+
```

## Consequences

- **Pros:**
  - **Eliminates Trait Method Collisions:** This is the primary benefit. It allows for safe composition of multiple, complex traits.
  - **Clean Internal API:** Provides a single, predictable entry point (`_process_single_asset`) for a given operation.
  - **High Cohesion:** Logic for a specific domain (like script processing) remains entirely within its dedicated trait.

- **Cons:**
  - **Indirection:** Adds a layer of abstraction that requires understanding the dispatcher's routing logic.
  - **Strict Naming Discipline:** Requires that new methods in traits follow the unique naming convention to be integrated into the dispatcher.
