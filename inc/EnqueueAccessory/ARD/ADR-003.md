# ADR-003: The Trait Dispatcher Pattern

**Date:** 2025-07-11
**Status:** Referenced by ADR-004

## Context

When a class uses multiple PHP traits, it can lead to a fatal error if two or more traits provide a method with the same name. For example, both `ScriptsEnqueueTrait` and `StylesEnqueueTrait` might logically need a method like `_process_asset()`. A class using both would fail.

We need a robust pattern to allow a class to safely compose functionality from multiple traits without risking these method name collisions.

## Decision

We will implement a **Trait Dispatcher Pattern**. This pattern involves a base class that consumes the traits and acts as a central router. The key components are:

1.  **Uniquely-Named Trait Methods:** The methods in the traits are given unique, specific names (e.g., `_process_single_script_asset()` instead of a generic name).
2.  **A Central Dispatcher Method:** The base class provides a single, generic method (e.g., `_process_single_asset()`).
3.  **A Routing Argument:** The dispatcher method accepts an argument (e.g., an `AssetType` enum) that tells it which type of logic to execute.
4.  **Internal Routing:** The dispatcher uses a `match` statement on the routing argument to forward the call to the correct, uniquely-named method from the appropriate trait.

### Architectural Diagram

This diagram shows the internal logic of the dispatcher pattern.

```ascii
// 1. An external call is made to the generic dispatcher method.
Call -> [DispatcherClass::_process_single_asset(AssetType::Script, ...)]
                                |
                                |
// 2. The dispatcher uses a `match` statement on the AssetType.
                                V
                      +--------------------+
                      | match($asset_type) |
                      +--------------------+
                      /                    \
                     /                      \
      (AssetType::Script)            (AssetType::Style)
            |                              |
            |
// 3. The call is dispatched to the uniquely-named method from the correct trait.
            V                              V
+---------------------------+    +--------------------------+
|  ScriptsEnqueueTrait::    |    |   StylesEnqueueTrait::   |
| _process_single_script..()|    | _process_single_style..()|
+---------------------------+    +--------------------------+
```

## Consequences

- **Pros:**
  - **Eliminates Trait Method Collisions:** This is the primary benefit. It allows for safe composition of multiple, complex traits.
  - **Clean Internal API:** Provides a single, predictable entry point (`_process_single_asset`) for a given operation.
  - **High Cohesion:** Logic for a specific domain (like script processing) remains entirely within its dedicated trait.

- **Cons:**
  - **Indirection:** Adds a layer of abstraction that requires understanding the dispatcher's routing logic.
  - **Strict Naming Discipline:** Requires that new methods in traits follow the unique naming convention to be integrated into the dispatcher.
